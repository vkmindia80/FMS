{"ast":null,"code":"import { useVirtualizer as Ee } from \"@tanstack/react-virtual\";\nimport w, { createContext as ie, createRef as Pe, Fragment as me, useCallback as Ie, useContext as ue, useEffect as Ve, useMemo as U, useReducer as _e, useRef as B, useState as Fe } from \"react\";\nimport { useComputed as pe } from '../../hooks/use-computed.js';\nimport { useControllable as Le } from '../../hooks/use-controllable.js';\nimport { useDisposables as se } from '../../hooks/use-disposables.js';\nimport { useEvent as m } from '../../hooks/use-event.js';\nimport { useId as Q } from '../../hooks/use-id.js';\nimport { useIsoMorphicEffect as H } from '../../hooks/use-iso-morphic-effect.js';\nimport { useLatestValue as De } from '../../hooks/use-latest-value.js';\nimport { useOutsideClick as Me } from '../../hooks/use-outside-click.js';\nimport { useOwnerDocument as he } from '../../hooks/use-owner.js';\nimport { useResolveButtonType as Be } from '../../hooks/use-resolve-button-type.js';\nimport { useSyncRefs as Z } from '../../hooks/use-sync-refs.js';\nimport { useTrackedPointer as ke } from '../../hooks/use-tracked-pointer.js';\nimport { useTreeWalker as we } from '../../hooks/use-tree-walker.js';\nimport { useWatch as Te } from '../../hooks/use-watch.js';\nimport { Features as Ue, Hidden as He } from '../../internal/hidden.js';\nimport { OpenClosedProvider as Ne, State as re, useOpenClosed as Ge } from '../../internal/open-closed.js';\nimport { history as xe } from '../../utils/active-element-history.js';\nimport { isDisabledReactIssue7711 as Xe } from '../../utils/bugs.js';\nimport { calculateActiveIndex as ge, Focus as y } from '../../utils/calculate-active-index.js';\nimport { disposables as ve } from '../../utils/disposables.js';\nimport { sortByDomNode as je } from '../../utils/focus-management.js';\nimport { objectToFormEntries as Je } from '../../utils/form.js';\nimport { match as W } from '../../utils/match.js';\nimport { isMobile as Ke } from '../../utils/platform.js';\nimport { compact as We, Features as Oe, forwardRefWithAs as $, render as q } from '../../utils/render.js';\nimport { Keys as M } from '../keyboard.js';\nvar $e = (o => (o[o.Open = 0] = \"Open\", o[o.Closed = 1] = \"Closed\", o))($e || {}),\n  qe = (o => (o[o.Single = 0] = \"Single\", o[o.Multi = 1] = \"Multi\", o))(qe || {}),\n  ze = (a => (a[a.Pointer = 0] = \"Pointer\", a[a.Focus = 1] = \"Focus\", a[a.Other = 2] = \"Other\", a))(ze || {}),\n  Ye = (e => (e[e.OpenCombobox = 0] = \"OpenCombobox\", e[e.CloseCombobox = 1] = \"CloseCombobox\", e[e.GoToOption = 2] = \"GoToOption\", e[e.RegisterOption = 3] = \"RegisterOption\", e[e.UnregisterOption = 4] = \"UnregisterOption\", e[e.RegisterLabel = 5] = \"RegisterLabel\", e[e.SetActivationTrigger = 6] = \"SetActivationTrigger\", e[e.UpdateVirtualOptions = 7] = \"UpdateVirtualOptions\", e))(Ye || {});\nfunction de(t, r = o => o) {\n  let o = t.activeOptionIndex !== null ? t.options[t.activeOptionIndex] : null,\n    a = r(t.options.slice()),\n    i = a.length > 0 && a[0].dataRef.current.order !== null ? a.sort((p, c) => p.dataRef.current.order - c.dataRef.current.order) : je(a, p => p.dataRef.current.domRef.current),\n    u = o ? i.indexOf(o) : null;\n  return u === -1 && (u = null), {\n    options: i,\n    activeOptionIndex: u\n  };\n}\nlet Qe = {\n    [1](t) {\n      var r;\n      return (r = t.dataRef.current) != null && r.disabled || t.comboboxState === 1 ? t : {\n        ...t,\n        activeOptionIndex: null,\n        comboboxState: 1\n      };\n    },\n    [0](t) {\n      var r, o;\n      if ((r = t.dataRef.current) != null && r.disabled || t.comboboxState === 0) return t;\n      if ((o = t.dataRef.current) != null && o.value) {\n        let a = t.dataRef.current.calculateIndex(t.dataRef.current.value);\n        if (a !== -1) return {\n          ...t,\n          activeOptionIndex: a,\n          comboboxState: 0\n        };\n      }\n      return {\n        ...t,\n        comboboxState: 0\n      };\n    },\n    [2](t, r) {\n      var u, p, c, e, l;\n      if ((u = t.dataRef.current) != null && u.disabled || (p = t.dataRef.current) != null && p.optionsRef.current && !((c = t.dataRef.current) != null && c.optionsPropsRef.current.static) && t.comboboxState === 1) return t;\n      if (t.virtual) {\n        let T = r.focus === y.Specific ? r.idx : ge(r, {\n            resolveItems: () => t.virtual.options,\n            resolveActiveIndex: () => {\n              var f, v;\n              return (v = (f = t.activeOptionIndex) != null ? f : t.virtual.options.findIndex(S => !t.virtual.disabled(S))) != null ? v : null;\n            },\n            resolveDisabled: t.virtual.disabled,\n            resolveId() {\n              throw new Error(\"Function not implemented.\");\n            }\n          }),\n          g = (e = r.trigger) != null ? e : 2;\n        return t.activeOptionIndex === T && t.activationTrigger === g ? t : {\n          ...t,\n          activeOptionIndex: T,\n          activationTrigger: g\n        };\n      }\n      let o = de(t);\n      if (o.activeOptionIndex === null) {\n        let T = o.options.findIndex(g => !g.dataRef.current.disabled);\n        T !== -1 && (o.activeOptionIndex = T);\n      }\n      let a = r.focus === y.Specific ? r.idx : ge(r, {\n          resolveItems: () => o.options,\n          resolveActiveIndex: () => o.activeOptionIndex,\n          resolveId: T => T.id,\n          resolveDisabled: T => T.dataRef.current.disabled\n        }),\n        i = (l = r.trigger) != null ? l : 2;\n      return t.activeOptionIndex === a && t.activationTrigger === i ? t : {\n        ...t,\n        ...o,\n        activeOptionIndex: a,\n        activationTrigger: i\n      };\n    },\n    [3]: (t, r) => {\n      var u, p, c;\n      if ((u = t.dataRef.current) != null && u.virtual) return {\n        ...t,\n        options: [...t.options, r.payload]\n      };\n      let o = r.payload,\n        a = de(t, e => (e.push(o), e));\n      t.activeOptionIndex === null && (p = t.dataRef.current) != null && p.isSelected(r.payload.dataRef.current.value) && (a.activeOptionIndex = a.options.indexOf(o));\n      let i = {\n        ...t,\n        ...a,\n        activationTrigger: 2\n      };\n      return (c = t.dataRef.current) != null && c.__demoMode && t.dataRef.current.value === void 0 && (i.activeOptionIndex = 0), i;\n    },\n    [4]: (t, r) => {\n      var a;\n      if ((a = t.dataRef.current) != null && a.virtual) return {\n        ...t,\n        options: t.options.filter(i => i.id !== r.id)\n      };\n      let o = de(t, i => {\n        let u = i.findIndex(p => p.id === r.id);\n        return u !== -1 && i.splice(u, 1), i;\n      });\n      return {\n        ...t,\n        ...o,\n        activationTrigger: 2\n      };\n    },\n    [5]: (t, r) => t.labelId === r.id ? t : {\n      ...t,\n      labelId: r.id\n    },\n    [6]: (t, r) => t.activationTrigger === r.trigger ? t : {\n      ...t,\n      activationTrigger: r.trigger\n    },\n    [7]: (t, r) => {\n      var a;\n      if (((a = t.virtual) == null ? void 0 : a.options) === r.options) return t;\n      let o = t.activeOptionIndex;\n      if (t.activeOptionIndex !== null) {\n        let i = r.options.indexOf(t.virtual.options[t.activeOptionIndex]);\n        i !== -1 ? o = i : o = null;\n      }\n      return {\n        ...t,\n        activeOptionIndex: o,\n        virtual: Object.assign({}, t.virtual, {\n          options: r.options\n        })\n      };\n    }\n  },\n  be = ie(null);\nbe.displayName = \"ComboboxActionsContext\";\nfunction ee(t) {\n  let r = ue(be);\n  if (r === null) {\n    let o = new Error(`<${t} /> is missing a parent <Combobox /> component.`);\n    throw Error.captureStackTrace && Error.captureStackTrace(o, ee), o;\n  }\n  return r;\n}\nlet Ce = ie(null);\nfunction Ze(t) {\n  var c;\n  let r = j(\"VirtualProvider\"),\n    [o, a] = U(() => {\n      let e = r.optionsRef.current;\n      if (!e) return [0, 0];\n      let l = window.getComputedStyle(e);\n      return [parseFloat(l.paddingBlockStart || l.paddingTop), parseFloat(l.paddingBlockEnd || l.paddingBottom)];\n    }, [r.optionsRef.current]),\n    i = Ee({\n      scrollPaddingStart: o,\n      scrollPaddingEnd: a,\n      count: r.virtual.options.length,\n      estimateSize() {\n        return 40;\n      },\n      getScrollElement() {\n        var e;\n        return (e = r.optionsRef.current) != null ? e : null;\n      },\n      overscan: 12\n    }),\n    [u, p] = Fe(0);\n  return H(() => {\n    p(e => e + 1);\n  }, [(c = r.virtual) == null ? void 0 : c.options]), w.createElement(Ce.Provider, {\n    value: i\n  }, w.createElement(\"div\", {\n    style: {\n      position: \"relative\",\n      width: \"100%\",\n      height: `${i.getTotalSize()}px`\n    },\n    ref: e => {\n      if (e) {\n        if (typeof process != \"undefined\" && process.env.JEST_WORKER_ID !== void 0 || r.activationTrigger === 0) return;\n        r.activeOptionIndex !== null && r.virtual.options.length > r.activeOptionIndex && i.scrollToIndex(r.activeOptionIndex);\n      }\n    }\n  }, i.getVirtualItems().map(e => {\n    var l;\n    return w.createElement(me, {\n      key: e.key\n    }, w.cloneElement((l = t.children) == null ? void 0 : l.call(t, {\n      option: r.virtual.options[e.index],\n      open: r.comboboxState === 0\n    }), {\n      key: `${u}-${e.key}`,\n      \"data-index\": e.index,\n      \"aria-setsize\": r.virtual.options.length,\n      \"aria-posinset\": e.index + 1,\n      style: {\n        position: \"absolute\",\n        top: 0,\n        left: 0,\n        transform: `translateY(${e.start}px)`,\n        overflowAnchor: \"none\"\n      }\n    }));\n  })));\n}\nlet ce = ie(null);\nce.displayName = \"ComboboxDataContext\";\nfunction j(t) {\n  let r = ue(ce);\n  if (r === null) {\n    let o = new Error(`<${t} /> is missing a parent <Combobox /> component.`);\n    throw Error.captureStackTrace && Error.captureStackTrace(o, j), o;\n  }\n  return r;\n}\nfunction et(t, r) {\n  return W(r.type, Qe, t, r);\n}\nlet tt = me;\nfunction ot(t, r) {\n  var fe;\n  let {\n      value: o,\n      defaultValue: a,\n      onChange: i,\n      form: u,\n      name: p,\n      by: c = null,\n      disabled: e = !1,\n      __demoMode: l = !1,\n      nullable: T = !1,\n      multiple: g = !1,\n      immediate: f = !1,\n      virtual: v = null,\n      ...S\n    } = t,\n    R = !1,\n    s = null,\n    [I = g ? [] : void 0, V] = Le(o, i, a),\n    [_, E] = _e(et, {\n      dataRef: Pe(),\n      comboboxState: l ? 0 : 1,\n      options: [],\n      virtual: s ? {\n        options: s.options,\n        disabled: (fe = s.disabled) != null ? fe : () => !1\n      } : null,\n      activeOptionIndex: null,\n      activationTrigger: 2,\n      labelId: null\n    }),\n    k = B(!1),\n    J = B({\n      static: !1,\n      hold: !1\n    }),\n    K = B(null),\n    z = B(null),\n    te = B(null),\n    X = B(null),\n    x = m(typeof c == \"string\" ? (d, b) => {\n      let P = c;\n      return (d == null ? void 0 : d[P]) === (b == null ? void 0 : b[P]);\n    } : c != null ? c : (d, b) => d === b),\n    O = m(d => s ? c === null ? s.options.indexOf(d) : s.options.findIndex(b => x(b, d)) : _.options.findIndex(b => x(b.dataRef.current.value, d))),\n    L = Ie(d => W(n.mode, {\n      [1]: () => I.some(b => x(b, d)),\n      [0]: () => x(I, d)\n    }), [I]),\n    oe = m(d => _.activeOptionIndex === O(d)),\n    n = U(() => ({\n      ..._,\n      immediate: R,\n      optionsPropsRef: J,\n      labelRef: K,\n      inputRef: z,\n      buttonRef: te,\n      optionsRef: X,\n      value: I,\n      defaultValue: a,\n      disabled: e,\n      mode: g ? 1 : 0,\n      virtual: _.virtual,\n      get activeOptionIndex() {\n        if (k.current && _.activeOptionIndex === null && (s ? s.options.length > 0 : _.options.length > 0)) {\n          if (s) {\n            let b = s.options.findIndex(P => {\n              var G, Y;\n              return !((Y = (G = s == null ? void 0 : s.disabled) == null ? void 0 : G.call(s, P)) != null && Y);\n            });\n            if (b !== -1) return b;\n          }\n          let d = _.options.findIndex(b => !b.dataRef.current.disabled);\n          if (d !== -1) return d;\n        }\n        return _.activeOptionIndex;\n      },\n      calculateIndex: O,\n      compare: x,\n      isSelected: L,\n      isActive: oe,\n      nullable: T,\n      __demoMode: l\n    }), [I, a, e, g, T, l, _, s]);\n  H(() => {\n    s && E({\n      type: 7,\n      options: s.options\n    });\n  }, [s, s == null ? void 0 : s.options]), H(() => {\n    _.dataRef.current = n;\n  }, [n]), Me([n.buttonRef, n.inputRef, n.optionsRef], () => le.closeCombobox(), n.comboboxState === 0);\n  let F = U(() => {\n      var d, b, P;\n      return {\n        open: n.comboboxState === 0,\n        disabled: e,\n        activeIndex: n.activeOptionIndex,\n        activeOption: n.activeOptionIndex === null ? null : n.virtual ? n.virtual.options[(d = n.activeOptionIndex) != null ? d : 0] : (P = (b = n.options[n.activeOptionIndex]) == null ? void 0 : b.dataRef.current.value) != null ? P : null,\n        value: I\n      };\n    }, [n, e, I]),\n    A = m(() => {\n      if (n.activeOptionIndex !== null) {\n        if (n.virtual) ae(n.virtual.options[n.activeOptionIndex]);else {\n          let {\n            dataRef: d\n          } = n.options[n.activeOptionIndex];\n          ae(d.current.value);\n        }\n        le.goToOption(y.Specific, n.activeOptionIndex);\n      }\n    }),\n    h = m(() => {\n      E({\n        type: 0\n      }), k.current = !0;\n    }),\n    C = m(() => {\n      E({\n        type: 1\n      }), k.current = !1;\n    }),\n    D = m((d, b, P) => (k.current = !1, d === y.Specific ? E({\n      type: 2,\n      focus: y.Specific,\n      idx: b,\n      trigger: P\n    }) : E({\n      type: 2,\n      focus: d,\n      trigger: P\n    }))),\n    N = m((d, b) => (E({\n      type: 3,\n      payload: {\n        id: d,\n        dataRef: b\n      }\n    }), () => {\n      n.isActive(b.current.value) && (k.current = !0), E({\n        type: 4,\n        id: d\n      });\n    })),\n    ye = m(d => (E({\n      type: 5,\n      id: d\n    }), () => E({\n      type: 5,\n      id: null\n    }))),\n    ae = m(d => W(n.mode, {\n      [0]() {\n        return V == null ? void 0 : V(d);\n      },\n      [1]() {\n        let b = n.value.slice(),\n          P = b.findIndex(G => x(G, d));\n        return P === -1 ? b.push(d) : b.splice(P, 1), V == null ? void 0 : V(b);\n      }\n    })),\n    Re = m(d => {\n      E({\n        type: 6,\n        trigger: d\n      });\n    }),\n    le = U(() => ({\n      onChange: ae,\n      registerOption: N,\n      registerLabel: ye,\n      goToOption: D,\n      closeCombobox: C,\n      openCombobox: h,\n      setActivationTrigger: Re,\n      selectActiveOption: A\n    }), []),\n    Ae = r === null ? {} : {\n      ref: r\n    },\n    ne = B(null),\n    Se = se();\n  return Ve(() => {\n    ne.current && a !== void 0 && Se.addEventListener(ne.current, \"reset\", () => {\n      V == null || V(a);\n    });\n  }, [ne, V]), w.createElement(be.Provider, {\n    value: le\n  }, w.createElement(ce.Provider, {\n    value: n\n  }, w.createElement(Ne, {\n    value: W(n.comboboxState, {\n      [0]: re.Open,\n      [1]: re.Closed\n    })\n  }, p != null && I != null && Je({\n    [p]: I\n  }).map(([d, b], P) => w.createElement(He, {\n    features: Ue.Hidden,\n    ref: P === 0 ? G => {\n      var Y;\n      ne.current = (Y = G == null ? void 0 : G.closest(\"form\")) != null ? Y : null;\n    } : void 0,\n    ...We({\n      key: d,\n      as: \"input\",\n      type: \"hidden\",\n      hidden: !0,\n      readOnly: !0,\n      form: u,\n      disabled: e,\n      name: d,\n      value: b\n    })\n  })), q({\n    ourProps: Ae,\n    theirProps: S,\n    slot: F,\n    defaultTag: tt,\n    name: \"Combobox\"\n  }))));\n}\nlet nt = \"input\";\nfunction rt(t, r) {\n  var X, x, O, L, oe;\n  let o = Q(),\n    {\n      id: a = `headlessui-combobox-input-${o}`,\n      onChange: i,\n      displayValue: u,\n      type: p = \"text\",\n      ...c\n    } = t,\n    e = j(\"Combobox.Input\"),\n    l = ee(\"Combobox.Input\"),\n    T = Z(e.inputRef, r),\n    g = he(e.inputRef),\n    f = B(!1),\n    v = se(),\n    S = m(() => {\n      l.onChange(null), e.optionsRef.current && (e.optionsRef.current.scrollTop = 0), l.goToOption(y.Nothing);\n    }),\n    R = function () {\n      var n;\n      return typeof u == \"function\" && e.value !== void 0 ? (n = u(e.value)) != null ? n : \"\" : typeof e.value == \"string\" ? e.value : \"\";\n    }();\n  Te(([n, F], [A, h]) => {\n    if (f.current) return;\n    let C = e.inputRef.current;\n    C && ((h === 0 && F === 1 || n !== A) && (C.value = n), requestAnimationFrame(() => {\n      if (f.current || !C || (g == null ? void 0 : g.activeElement) !== C) return;\n      let {\n        selectionStart: D,\n        selectionEnd: N\n      } = C;\n      Math.abs((N != null ? N : 0) - (D != null ? D : 0)) === 0 && D === 0 && C.setSelectionRange(C.value.length, C.value.length);\n    }));\n  }, [R, e.comboboxState, g]), Te(([n], [F]) => {\n    if (n === 0 && F === 1) {\n      if (f.current) return;\n      let A = e.inputRef.current;\n      if (!A) return;\n      let h = A.value,\n        {\n          selectionStart: C,\n          selectionEnd: D,\n          selectionDirection: N\n        } = A;\n      A.value = \"\", A.value = h, N !== null ? A.setSelectionRange(C, D, N) : A.setSelectionRange(C, D);\n    }\n  }, [e.comboboxState]);\n  let s = B(!1),\n    I = m(() => {\n      s.current = !0;\n    }),\n    V = m(() => {\n      v.nextFrame(() => {\n        s.current = !1;\n      });\n    }),\n    _ = m(n => {\n      switch (f.current = !0, n.key) {\n        case M.Enter:\n          if (f.current = !1, e.comboboxState !== 0 || s.current) return;\n          if (n.preventDefault(), n.stopPropagation(), e.activeOptionIndex === null) {\n            l.closeCombobox();\n            return;\n          }\n          l.selectActiveOption(), e.mode === 0 && l.closeCombobox();\n          break;\n        case M.ArrowDown:\n          return f.current = !1, n.preventDefault(), n.stopPropagation(), W(e.comboboxState, {\n            [0]: () => l.goToOption(y.Next),\n            [1]: () => l.openCombobox()\n          });\n        case M.ArrowUp:\n          return f.current = !1, n.preventDefault(), n.stopPropagation(), W(e.comboboxState, {\n            [0]: () => l.goToOption(y.Previous),\n            [1]: () => {\n              l.openCombobox(), v.nextFrame(() => {\n                e.value || l.goToOption(y.Last);\n              });\n            }\n          });\n        case M.Home:\n          if (n.shiftKey) break;\n          return f.current = !1, n.preventDefault(), n.stopPropagation(), l.goToOption(y.First);\n        case M.PageUp:\n          return f.current = !1, n.preventDefault(), n.stopPropagation(), l.goToOption(y.First);\n        case M.End:\n          if (n.shiftKey) break;\n          return f.current = !1, n.preventDefault(), n.stopPropagation(), l.goToOption(y.Last);\n        case M.PageDown:\n          return f.current = !1, n.preventDefault(), n.stopPropagation(), l.goToOption(y.Last);\n        case M.Escape:\n          return f.current = !1, e.comboboxState !== 0 ? void 0 : (n.preventDefault(), e.optionsRef.current && !e.optionsPropsRef.current.static && n.stopPropagation(), e.nullable && e.mode === 0 && e.value === null && S(), l.closeCombobox());\n        case M.Tab:\n          if (f.current = !1, e.comboboxState !== 0) return;\n          e.mode === 0 && e.activationTrigger !== 1 && l.selectActiveOption(), l.closeCombobox();\n          break;\n      }\n    }),\n    E = m(n => {\n      i == null || i(n), e.nullable && e.mode === 0 && n.target.value === \"\" && S(), l.openCombobox();\n    }),\n    k = m(n => {\n      var A, h, C;\n      let F = (A = n.relatedTarget) != null ? A : xe.find(D => D !== n.currentTarget);\n      if (f.current = !1, !((h = e.optionsRef.current) != null && h.contains(F)) && !((C = e.buttonRef.current) != null && C.contains(F)) && e.comboboxState === 0) return n.preventDefault(), e.mode === 0 && (e.nullable && e.value === null ? S() : e.activationTrigger !== 1 && l.selectActiveOption()), l.closeCombobox();\n    }),\n    J = m(n => {\n      var A, h, C;\n      let F = (A = n.relatedTarget) != null ? A : xe.find(D => D !== n.currentTarget);\n      (h = e.buttonRef.current) != null && h.contains(F) || (C = e.optionsRef.current) != null && C.contains(F) || e.disabled || e.immediate && e.comboboxState !== 0 && (l.openCombobox(), v.nextFrame(() => {\n        l.setActivationTrigger(1);\n      }));\n    }),\n    K = pe(() => {\n      if (e.labelId) return [e.labelId].join(\" \");\n    }, [e.labelId]),\n    z = U(() => ({\n      open: e.comboboxState === 0,\n      disabled: e.disabled\n    }), [e]),\n    te = {\n      ref: T,\n      id: a,\n      role: \"combobox\",\n      type: p,\n      \"aria-controls\": (X = e.optionsRef.current) == null ? void 0 : X.id,\n      \"aria-expanded\": e.comboboxState === 0,\n      \"aria-activedescendant\": e.activeOptionIndex === null ? void 0 : e.virtual ? (x = e.options.find(n => {\n        var F;\n        return !((F = e.virtual) != null && F.disabled(n.dataRef.current.value)) && e.compare(n.dataRef.current.value, e.virtual.options[e.activeOptionIndex]);\n      })) == null ? void 0 : x.id : (O = e.options[e.activeOptionIndex]) == null ? void 0 : O.id,\n      \"aria-labelledby\": K,\n      \"aria-autocomplete\": \"list\",\n      defaultValue: (oe = (L = t.defaultValue) != null ? L : e.defaultValue !== void 0 ? u == null ? void 0 : u(e.defaultValue) : null) != null ? oe : e.defaultValue,\n      disabled: e.disabled,\n      onCompositionStart: I,\n      onCompositionEnd: V,\n      onKeyDown: _,\n      onChange: E,\n      onFocus: J,\n      onBlur: k\n    };\n  return q({\n    ourProps: te,\n    theirProps: c,\n    slot: z,\n    defaultTag: nt,\n    name: \"Combobox.Input\"\n  });\n}\nlet at = \"button\";\nfunction lt(t, r) {\n  var S;\n  let o = j(\"Combobox.Button\"),\n    a = ee(\"Combobox.Button\"),\n    i = Z(o.buttonRef, r),\n    u = Q(),\n    {\n      id: p = `headlessui-combobox-button-${u}`,\n      ...c\n    } = t,\n    e = se(),\n    l = m(R => {\n      switch (R.key) {\n        case M.ArrowDown:\n          return R.preventDefault(), R.stopPropagation(), o.comboboxState === 1 && a.openCombobox(), e.nextFrame(() => {\n            var s;\n            return (s = o.inputRef.current) == null ? void 0 : s.focus({\n              preventScroll: !0\n            });\n          });\n        case M.ArrowUp:\n          return R.preventDefault(), R.stopPropagation(), o.comboboxState === 1 && (a.openCombobox(), e.nextFrame(() => {\n            o.value || a.goToOption(y.Last);\n          })), e.nextFrame(() => {\n            var s;\n            return (s = o.inputRef.current) == null ? void 0 : s.focus({\n              preventScroll: !0\n            });\n          });\n        case M.Escape:\n          return o.comboboxState !== 0 ? void 0 : (R.preventDefault(), o.optionsRef.current && !o.optionsPropsRef.current.static && R.stopPropagation(), a.closeCombobox(), e.nextFrame(() => {\n            var s;\n            return (s = o.inputRef.current) == null ? void 0 : s.focus({\n              preventScroll: !0\n            });\n          }));\n        default:\n          return;\n      }\n    }),\n    T = m(R => {\n      if (Xe(R.currentTarget)) return R.preventDefault();\n      o.comboboxState === 0 ? a.closeCombobox() : (R.preventDefault(), a.openCombobox()), e.nextFrame(() => {\n        var s;\n        return (s = o.inputRef.current) == null ? void 0 : s.focus({\n          preventScroll: !0\n        });\n      });\n    }),\n    g = pe(() => {\n      if (o.labelId) return [o.labelId, p].join(\" \");\n    }, [o.labelId, p]),\n    f = U(() => ({\n      open: o.comboboxState === 0,\n      disabled: o.disabled,\n      value: o.value\n    }), [o]),\n    v = {\n      ref: i,\n      id: p,\n      type: Be(t, o.buttonRef),\n      tabIndex: -1,\n      \"aria-haspopup\": \"listbox\",\n      \"aria-controls\": (S = o.optionsRef.current) == null ? void 0 : S.id,\n      \"aria-expanded\": o.comboboxState === 0,\n      \"aria-labelledby\": g,\n      disabled: o.disabled,\n      onClick: T,\n      onKeyDown: l\n    };\n  return q({\n    ourProps: v,\n    theirProps: c,\n    slot: f,\n    defaultTag: at,\n    name: \"Combobox.Button\"\n  });\n}\nlet it = \"label\";\nfunction ut(t, r) {\n  let o = Q(),\n    {\n      id: a = `headlessui-combobox-label-${o}`,\n      ...i\n    } = t,\n    u = j(\"Combobox.Label\"),\n    p = ee(\"Combobox.Label\"),\n    c = Z(u.labelRef, r);\n  H(() => p.registerLabel(a), [a]);\n  let e = m(() => {\n      var g;\n      return (g = u.inputRef.current) == null ? void 0 : g.focus({\n        preventScroll: !0\n      });\n    }),\n    l = U(() => ({\n      open: u.comboboxState === 0,\n      disabled: u.disabled\n    }), [u]);\n  return q({\n    ourProps: {\n      ref: c,\n      id: a,\n      onClick: e\n    },\n    theirProps: i,\n    slot: l,\n    defaultTag: it,\n    name: \"Combobox.Label\"\n  });\n}\nlet pt = \"ul\",\n  st = Oe.RenderStrategy | Oe.Static;\nfunction dt(t, r) {\n  let o = Q(),\n    {\n      id: a = `headlessui-combobox-options-${o}`,\n      hold: i = !1,\n      ...u\n    } = t,\n    p = j(\"Combobox.Options\"),\n    c = Z(p.optionsRef, r),\n    e = Ge(),\n    l = (() => e !== null ? (e & re.Open) === re.Open : p.comboboxState === 0)();\n  H(() => {\n    var v;\n    p.optionsPropsRef.current.static = (v = t.static) != null ? v : !1;\n  }, [p.optionsPropsRef, t.static]), H(() => {\n    p.optionsPropsRef.current.hold = i;\n  }, [p.optionsPropsRef, i]), we({\n    container: p.optionsRef.current,\n    enabled: p.comboboxState === 0,\n    accept(v) {\n      return v.getAttribute(\"role\") === \"option\" ? NodeFilter.FILTER_REJECT : v.hasAttribute(\"role\") ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_ACCEPT;\n    },\n    walk(v) {\n      v.setAttribute(\"role\", \"none\");\n    }\n  });\n  let T = pe(() => {\n      var v, S;\n      return (S = p.labelId) != null ? S : (v = p.buttonRef.current) == null ? void 0 : v.id;\n    }, [p.labelId, p.buttonRef.current]),\n    g = U(() => ({\n      open: p.comboboxState === 0,\n      option: void 0\n    }), [p]),\n    f = {\n      \"aria-labelledby\": T,\n      role: \"listbox\",\n      \"aria-multiselectable\": p.mode === 1 ? !0 : void 0,\n      id: a,\n      ref: c\n    };\n  return p.virtual && p.comboboxState === 0 && Object.assign(u, {\n    children: w.createElement(Ze, null, u.children)\n  }), q({\n    ourProps: f,\n    theirProps: u,\n    slot: g,\n    defaultTag: pt,\n    features: st,\n    visible: l,\n    name: \"Combobox.Options\"\n  });\n}\nlet bt = \"li\";\nfunction ct(t, r) {\n  var X;\n  let o = Q(),\n    {\n      id: a = `headlessui-combobox-option-${o}`,\n      disabled: i = !1,\n      value: u,\n      order: p = null,\n      ...c\n    } = t,\n    e = j(\"Combobox.Option\"),\n    l = ee(\"Combobox.Option\"),\n    T = e.virtual ? e.activeOptionIndex === e.calculateIndex(u) : e.activeOptionIndex === null ? !1 : ((X = e.options[e.activeOptionIndex]) == null ? void 0 : X.id) === a,\n    g = e.isSelected(u),\n    f = B(null),\n    v = De({\n      disabled: i,\n      value: u,\n      domRef: f,\n      order: p\n    }),\n    S = ue(Ce),\n    R = Z(r, f, S ? S.measureElement : null),\n    s = m(() => l.onChange(u));\n  H(() => l.registerOption(a, v), [v, a]);\n  let I = B(!(e.virtual || e.__demoMode));\n  H(() => {\n    if (!e.virtual || !e.__demoMode) return;\n    let x = ve();\n    return x.requestAnimationFrame(() => {\n      I.current = !0;\n    }), x.dispose;\n  }, [e.virtual, e.__demoMode]), H(() => {\n    if (!I.current || e.comboboxState !== 0 || !T || e.activationTrigger === 0) return;\n    let x = ve();\n    return x.requestAnimationFrame(() => {\n      var O, L;\n      (L = (O = f.current) == null ? void 0 : O.scrollIntoView) == null || L.call(O, {\n        block: \"nearest\"\n      });\n    }), x.dispose;\n  }, [f, T, e.comboboxState, e.activationTrigger, e.activeOptionIndex]);\n  let V = m(x => {\n      var O;\n      if (i || (O = e.virtual) != null && O.disabled(u)) return x.preventDefault();\n      s(), Ke() || requestAnimationFrame(() => {\n        var L;\n        return (L = e.inputRef.current) == null ? void 0 : L.focus({\n          preventScroll: !0\n        });\n      }), e.mode === 0 && requestAnimationFrame(() => l.closeCombobox());\n    }),\n    _ = m(() => {\n      var O;\n      if (i || (O = e.virtual) != null && O.disabled(u)) return l.goToOption(y.Nothing);\n      let x = e.calculateIndex(u);\n      l.goToOption(y.Specific, x);\n    }),\n    E = ke(),\n    k = m(x => E.update(x)),\n    J = m(x => {\n      var L;\n      if (!E.wasMoved(x) || i || (L = e.virtual) != null && L.disabled(u) || T) return;\n      let O = e.calculateIndex(u);\n      l.goToOption(y.Specific, O, 0);\n    }),\n    K = m(x => {\n      var O;\n      E.wasMoved(x) && (i || (O = e.virtual) != null && O.disabled(u) || T && (e.optionsPropsRef.current.hold || l.goToOption(y.Nothing)));\n    }),\n    z = U(() => ({\n      active: T,\n      selected: g,\n      disabled: i\n    }), [T, g, i]);\n  return q({\n    ourProps: {\n      id: a,\n      ref: R,\n      role: \"option\",\n      tabIndex: i === !0 ? void 0 : -1,\n      \"aria-disabled\": i === !0 ? !0 : void 0,\n      \"aria-selected\": g,\n      disabled: void 0,\n      onClick: V,\n      onFocus: _,\n      onPointerEnter: k,\n      onMouseEnter: k,\n      onPointerMove: J,\n      onMouseMove: J,\n      onPointerLeave: K,\n      onMouseLeave: K\n    },\n    theirProps: c,\n    slot: z,\n    defaultTag: bt,\n    name: \"Combobox.Option\"\n  });\n}\nlet ft = $(ot),\n  mt = $(lt),\n  Tt = $(rt),\n  xt = $(ut),\n  gt = $(dt),\n  vt = $(ct),\n  qt = Object.assign(ft, {\n    Input: Tt,\n    Button: mt,\n    Label: xt,\n    Options: gt,\n    Option: vt\n  });\nexport { qt as Combobox };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}