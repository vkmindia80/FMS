{"ast":null,"code":"import E, { useRef as d } from \"react\";\nimport { useDisposables as U } from '../../hooks/use-disposables.js';\nimport { useEvent as v } from '../../hooks/use-event.js';\nimport { useEventListener as x } from '../../hooks/use-event-listener.js';\nimport { useIsMounted as g } from '../../hooks/use-is-mounted.js';\nimport { useOnUnmount as N } from '../../hooks/use-on-unmount.js';\nimport { useOwnerDocument as I } from '../../hooks/use-owner.js';\nimport { useServerHandoffComplete as G } from '../../hooks/use-server-handoff-complete.js';\nimport { useSyncRefs as K } from '../../hooks/use-sync-refs.js';\nimport { Direction as L, useTabDirection as W } from '../../hooks/use-tab-direction.js';\nimport { useWatch as b } from '../../hooks/use-watch.js';\nimport { Features as A, Hidden as O } from '../../internal/hidden.js';\nimport { history as F } from '../../utils/active-element-history.js';\nimport { Focus as p, focusElement as f, focusIn as M, FocusResult as V } from '../../utils/focus-management.js';\nimport { match as k } from '../../utils/match.js';\nimport { microTask as C } from '../../utils/micro-task.js';\nimport { forwardRefWithAs as q, render as J } from '../../utils/render.js';\nfunction P(t) {\n  if (!t) return new Set();\n  if (typeof t == \"function\") return new Set(t());\n  let n = new Set();\n  for (let e of t.current) e.current instanceof HTMLElement && n.add(e.current);\n  return n;\n}\nlet X = \"div\";\nvar _ = (r => (r[r.None = 1] = \"None\", r[r.InitialFocus = 2] = \"InitialFocus\", r[r.TabLock = 4] = \"TabLock\", r[r.FocusLock = 8] = \"FocusLock\", r[r.RestoreFocus = 16] = \"RestoreFocus\", r[r.All = 30] = \"All\", r))(_ || {});\nfunction z(t, n) {\n  let e = d(null),\n    o = K(e, n),\n    {\n      initialFocus: l,\n      containers: c,\n      features: r = 30,\n      ...s\n    } = t;\n  G() || (r = 1);\n  let i = I(e);\n  Y({\n    ownerDocument: i\n  }, Boolean(r & 16));\n  let u = Z({\n    ownerDocument: i,\n    container: e,\n    initialFocus: l\n  }, Boolean(r & 2));\n  $({\n    ownerDocument: i,\n    container: e,\n    containers: c,\n    previousActiveElement: u\n  }, Boolean(r & 8));\n  let y = W(),\n    R = v(a => {\n      let m = e.current;\n      if (!m) return;\n      (B => B())(() => {\n        k(y.current, {\n          [L.Forwards]: () => {\n            M(m, p.First, {\n              skipElements: [a.relatedTarget]\n            });\n          },\n          [L.Backwards]: () => {\n            M(m, p.Last, {\n              skipElements: [a.relatedTarget]\n            });\n          }\n        });\n      });\n    }),\n    h = U(),\n    H = d(!1),\n    j = {\n      ref: o,\n      onKeyDown(a) {\n        a.key == \"Tab\" && (H.current = !0, h.requestAnimationFrame(() => {\n          H.current = !1;\n        }));\n      },\n      onBlur(a) {\n        let m = P(c);\n        e.current instanceof HTMLElement && m.add(e.current);\n        let T = a.relatedTarget;\n        T instanceof HTMLElement && T.dataset.headlessuiFocusGuard !== \"true\" && (S(m, T) || (H.current ? M(e.current, k(y.current, {\n          [L.Forwards]: () => p.Next,\n          [L.Backwards]: () => p.Previous\n        }) | p.WrapAround, {\n          relativeTo: a.target\n        }) : a.target instanceof HTMLElement && f(a.target)));\n      }\n    };\n  return E.createElement(E.Fragment, null, Boolean(r & 4) && E.createElement(O, {\n    as: \"button\",\n    type: \"button\",\n    \"data-headlessui-focus-guard\": !0,\n    onFocus: R,\n    features: A.Focusable\n  }), J({\n    ourProps: j,\n    theirProps: s,\n    defaultTag: X,\n    name: \"FocusTrap\"\n  }), Boolean(r & 4) && E.createElement(O, {\n    as: \"button\",\n    type: \"button\",\n    \"data-headlessui-focus-guard\": !0,\n    onFocus: R,\n    features: A.Focusable\n  }));\n}\nlet D = q(z),\n  de = Object.assign(D, {\n    features: _\n  });\nfunction Q(t = !0) {\n  let n = d(F.slice());\n  return b(([e], [o]) => {\n    o === !0 && e === !1 && C(() => {\n      n.current.splice(0);\n    }), o === !1 && e === !0 && (n.current = F.slice());\n  }, [t, F, n]), v(() => {\n    var e;\n    return (e = n.current.find(o => o != null && o.isConnected)) != null ? e : null;\n  });\n}\nfunction Y({\n  ownerDocument: t\n}, n) {\n  let e = Q(n);\n  b(() => {\n    n || (t == null ? void 0 : t.activeElement) === (t == null ? void 0 : t.body) && f(e());\n  }, [n]), N(() => {\n    n && f(e());\n  });\n}\nfunction Z({\n  ownerDocument: t,\n  container: n,\n  initialFocus: e\n}, o) {\n  let l = d(null),\n    c = g();\n  return b(() => {\n    if (!o) return;\n    let r = n.current;\n    r && C(() => {\n      if (!c.current) return;\n      let s = t == null ? void 0 : t.activeElement;\n      if (e != null && e.current) {\n        if ((e == null ? void 0 : e.current) === s) {\n          l.current = s;\n          return;\n        }\n      } else if (r.contains(s)) {\n        l.current = s;\n        return;\n      }\n      e != null && e.current ? f(e.current) : M(r, p.First) === V.Error && console.warn(\"There are no focusable elements inside the <FocusTrap />\"), l.current = t == null ? void 0 : t.activeElement;\n    });\n  }, [o]), l;\n}\nfunction $({\n  ownerDocument: t,\n  container: n,\n  containers: e,\n  previousActiveElement: o\n}, l) {\n  let c = g();\n  x(t == null ? void 0 : t.defaultView, \"focus\", r => {\n    if (!l || !c.current) return;\n    let s = P(e);\n    n.current instanceof HTMLElement && s.add(n.current);\n    let i = o.current;\n    if (!i) return;\n    let u = r.target;\n    u && u instanceof HTMLElement ? S(s, u) ? (o.current = u, f(u)) : (r.preventDefault(), r.stopPropagation(), f(i)) : f(o.current);\n  }, !0);\n}\nfunction S(t, n) {\n  for (let e of t) if (e.contains(n)) return !0;\n  return !1;\n}\nexport { de as FocusTrap };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}