{"ast":null,"code":"import { cloneElement as N, createElement as E, forwardRef as h, Fragment as g, isValidElement as P, useCallback as j, useRef as S } from \"react\";\nimport { classNames as b } from './class-names.js';\nimport { match as w } from './match.js';\nvar O = (n => (n[n.None = 0] = \"None\", n[n.RenderStrategy = 1] = \"RenderStrategy\", n[n.Static = 2] = \"Static\", n))(O || {}),\n  v = (e => (e[e.Unmount = 0] = \"Unmount\", e[e.Hidden = 1] = \"Hidden\", e))(v || {});\nfunction C({\n  ourProps: r,\n  theirProps: t,\n  slot: e,\n  defaultTag: n,\n  features: o,\n  visible: a = !0,\n  name: f,\n  mergeRefs: l\n}) {\n  l = l != null ? l : k;\n  let s = R(t, r);\n  if (a) return m(s, e, n, f, l);\n  let y = o != null ? o : 0;\n  if (y & 2) {\n    let {\n      static: u = !1,\n      ...d\n    } = s;\n    if (u) return m(d, e, n, f, l);\n  }\n  if (y & 1) {\n    let {\n      unmount: u = !0,\n      ...d\n    } = s;\n    return w(u ? 0 : 1, {\n      [0]() {\n        return null;\n      },\n      [1]() {\n        return m({\n          ...d,\n          hidden: !0,\n          style: {\n            display: \"none\"\n          }\n        }, e, n, f, l);\n      }\n    });\n  }\n  return m(s, e, n, f, l);\n}\nfunction m(r, t = {}, e, n, o) {\n  let {\n      as: a = e,\n      children: f,\n      refName: l = \"ref\",\n      ...s\n    } = F(r, [\"unmount\", \"static\"]),\n    y = r.ref !== void 0 ? {\n      [l]: r.ref\n    } : {},\n    u = typeof f == \"function\" ? f(t) : f;\n  \"className\" in s && s.className && typeof s.className == \"function\" && (s.className = s.className(t));\n  let d = {};\n  if (t) {\n    let i = !1,\n      c = [];\n    for (let [T, p] of Object.entries(t)) typeof p == \"boolean\" && (i = !0), p === !0 && c.push(T);\n    i && (d[\"data-headlessui-state\"] = c.join(\" \"));\n  }\n  if (a === g && Object.keys(x(s)).length > 0) {\n    if (!P(u) || Array.isArray(u) && u.length > 1) throw new Error(['Passing props on \"Fragment\"!', \"\", `The current component <${n} /> is rendering a \"Fragment\".`, \"However we need to passthrough the following props:\", Object.keys(s).map(p => `  - ${p}`).join(`\n`), \"\", \"You can apply a few solutions:\", ['Add an `as=\"...\"` prop, to ensure that we render an actual element instead of a \"Fragment\".', \"Render a single element as the child so that we can forward the props onto that element.\"].map(p => `  - ${p}`).join(`\n`)].join(`\n`));\n    let i = u.props,\n      c = typeof (i == null ? void 0 : i.className) == \"function\" ? (...p) => b(i == null ? void 0 : i.className(...p), s.className) : b(i == null ? void 0 : i.className, s.className),\n      T = c ? {\n        className: c\n      } : {};\n    return N(u, Object.assign({}, R(u.props, x(F(s, [\"ref\"]))), d, y, {\n      ref: o(u.ref, y.ref)\n    }, T));\n  }\n  return E(a, Object.assign({}, F(s, [\"ref\"]), a !== g && y, a !== g && d), u);\n}\nfunction I() {\n  let r = S([]),\n    t = j(e => {\n      for (let n of r.current) n != null && (typeof n == \"function\" ? n(e) : n.current = e);\n    }, []);\n  return (...e) => {\n    if (!e.every(n => n == null)) return r.current = e, t;\n  };\n}\nfunction k(...r) {\n  return r.every(t => t == null) ? void 0 : t => {\n    for (let e of r) e != null && (typeof e == \"function\" ? e(t) : e.current = t);\n  };\n}\nfunction R(...r) {\n  var n;\n  if (r.length === 0) return {};\n  if (r.length === 1) return r[0];\n  let t = {},\n    e = {};\n  for (let o of r) for (let a in o) a.startsWith(\"on\") && typeof o[a] == \"function\" ? ((n = e[a]) != null || (e[a] = []), e[a].push(o[a])) : t[a] = o[a];\n  if (t.disabled || t[\"aria-disabled\"]) return Object.assign(t, Object.fromEntries(Object.keys(e).map(o => [o, void 0])));\n  for (let o in e) Object.assign(t, {\n    [o](a, ...f) {\n      let l = e[o];\n      for (let s of l) {\n        if ((a instanceof Event || (a == null ? void 0 : a.nativeEvent) instanceof Event) && a.defaultPrevented) return;\n        s(a, ...f);\n      }\n    }\n  });\n  return t;\n}\nfunction U(r) {\n  var t;\n  return Object.assign(h(r), {\n    displayName: (t = r.displayName) != null ? t : r.name\n  });\n}\nfunction x(r) {\n  let t = Object.assign({}, r);\n  for (let e in t) t[e] === void 0 && delete t[e];\n  return t;\n}\nfunction F(r, t = []) {\n  let e = Object.assign({}, r);\n  for (let n of t) n in e && delete e[n];\n  return e;\n}\nexport { O as Features, v as RenderStrategy, x as compact, U as forwardRefWithAs, C as render, I as useMergeRefsFn };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}