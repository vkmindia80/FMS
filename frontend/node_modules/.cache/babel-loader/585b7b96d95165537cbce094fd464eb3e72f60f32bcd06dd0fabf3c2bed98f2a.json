{"ast":null,"code":"import T, { createContext as P, Fragment as m, useContext as s, useEffect as d, useMemo as g, useRef as R, useState as E } from \"react\";\nimport { createPortal as C } from \"react-dom\";\nimport { useEvent as c } from '../../hooks/use-event.js';\nimport { useIsoMorphicEffect as y } from '../../hooks/use-iso-morphic-effect.js';\nimport { useOnUnmount as H } from '../../hooks/use-on-unmount.js';\nimport { useOwnerDocument as x } from '../../hooks/use-owner.js';\nimport { useServerHandoffComplete as b } from '../../hooks/use-server-handoff-complete.js';\nimport { optionalRef as h, useSyncRefs as L } from '../../hooks/use-sync-refs.js';\nimport { usePortalRoot as O } from '../../internal/portal-force-root.js';\nimport { env as A } from '../../utils/env.js';\nimport { forwardRefWithAs as G, render as M } from '../../utils/render.js';\nfunction F(p) {\n  let n = O(),\n    l = s(_),\n    e = x(p),\n    [a, o] = E(() => {\n      if (!n && l !== null || A.isServer) return null;\n      let t = e == null ? void 0 : e.getElementById(\"headlessui-portal-root\");\n      if (t) return t;\n      if (e === null) return null;\n      let r = e.createElement(\"div\");\n      return r.setAttribute(\"id\", \"headlessui-portal-root\"), e.body.appendChild(r);\n    });\n  return d(() => {\n    a !== null && (e != null && e.body.contains(a) || e == null || e.body.appendChild(a));\n  }, [a, e]), d(() => {\n    n || l !== null && o(l.current);\n  }, [l, o, n]), a;\n}\nlet U = m;\nfunction N(p, n) {\n  let l = p,\n    e = R(null),\n    a = L(h(u => {\n      e.current = u;\n    }), n),\n    o = x(e),\n    t = F(e),\n    [r] = E(() => {\n      var u;\n      return A.isServer ? null : (u = o == null ? void 0 : o.createElement(\"div\")) != null ? u : null;\n    }),\n    i = s(f),\n    v = b();\n  return y(() => {\n    !t || !r || t.contains(r) || (r.setAttribute(\"data-headlessui-portal\", \"\"), t.appendChild(r));\n  }, [t, r]), y(() => {\n    if (r && i) return i.register(r);\n  }, [i, r]), H(() => {\n    var u;\n    !t || !r || (r instanceof Node && t.contains(r) && t.removeChild(r), t.childNodes.length <= 0 && ((u = t.parentElement) == null || u.removeChild(t)));\n  }), v ? !t || !r ? null : C(M({\n    ourProps: {\n      ref: a\n    },\n    theirProps: l,\n    defaultTag: U,\n    name: \"Portal\"\n  }), r) : null;\n}\nlet S = m,\n  _ = P(null);\nfunction j(p, n) {\n  let {\n      target: l,\n      ...e\n    } = p,\n    o = {\n      ref: L(n)\n    };\n  return T.createElement(_.Provider, {\n    value: l\n  }, M({\n    ourProps: o,\n    theirProps: e,\n    defaultTag: S,\n    name: \"Popover.Group\"\n  }));\n}\nlet f = P(null);\nfunction ee() {\n  let p = s(f),\n    n = R([]),\n    l = c(o => (n.current.push(o), p && p.register(o), () => e(o))),\n    e = c(o => {\n      let t = n.current.indexOf(o);\n      t !== -1 && n.current.splice(t, 1), p && p.unregister(o);\n    }),\n    a = g(() => ({\n      register: l,\n      unregister: e,\n      portals: n\n    }), [l, e, n]);\n  return [n, g(() => function ({\n    children: t\n  }) {\n    return T.createElement(f.Provider, {\n      value: a\n    }, t);\n  }, [a])];\n}\nlet D = G(N),\n  I = G(j),\n  te = Object.assign(D, {\n    Group: I\n  });\nexport { te as Portal, ee as useNestedPortals };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}