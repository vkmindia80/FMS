{"ast":null,"code":"import C, { createContext as Q, createRef as de, useContext as Z, useEffect as ee, useMemo as h, useReducer as ge, useRef as J, useState as ce } from \"react\";\nimport { useNestedPortals as Se } from '../../components/portal/portal.js';\nimport { useEvent as R } from '../../hooks/use-event.js';\nimport { useEventListener as Re } from '../../hooks/use-event-listener.js';\nimport { useId as K } from '../../hooks/use-id.js';\nimport { useIsoMorphicEffect as Ae } from '../../hooks/use-iso-morphic-effect.js';\nimport { useLatestValue as ve } from '../../hooks/use-latest-value.js';\nimport { useOutsideClick as Oe } from '../../hooks/use-outside-click.js';\nimport { useOwnerDocument as ne } from '../../hooks/use-owner.js';\nimport { useResolveButtonType as Ce } from '../../hooks/use-resolve-button-type.js';\nimport { useMainTreeNode as Me, useRootContainers as xe } from '../../hooks/use-root-containers.js';\nimport { optionalRef as Fe, useSyncRefs as j } from '../../hooks/use-sync-refs.js';\nimport { Direction as H, useTabDirection as Te } from '../../hooks/use-tab-direction.js';\nimport { Features as le, Hidden as ae } from '../../internal/hidden.js';\nimport { OpenClosedProvider as Ie, State as V, useOpenClosed as me } from '../../internal/open-closed.js';\nimport { isDisabledReactIssue7711 as ye } from '../../utils/bugs.js';\nimport { Focus as G, FocusableMode as _e, focusIn as N, FocusResult as pe, getFocusableElements as se, isFocusableElement as Le } from '../../utils/focus-management.js';\nimport { match as k } from '../../utils/match.js';\nimport '../../utils/micro-task.js';\nimport { getOwnerDocument as Be } from '../../utils/owner.js';\nimport { Features as te, forwardRefWithAs as X, render as Y, useMergeRefsFn as De } from '../../utils/render.js';\nimport { Keys as w } from '../keyboard.js';\nvar he = (u => (u[u.Open = 0] = \"Open\", u[u.Closed = 1] = \"Closed\", u))(he || {}),\n  He = (e => (e[e.TogglePopover = 0] = \"TogglePopover\", e[e.ClosePopover = 1] = \"ClosePopover\", e[e.SetButton = 2] = \"SetButton\", e[e.SetButtonId = 3] = \"SetButtonId\", e[e.SetPanel = 4] = \"SetPanel\", e[e.SetPanelId = 5] = \"SetPanelId\", e))(He || {});\nlet Ge = {\n    [0]: t => {\n      let o = {\n        ...t,\n        popoverState: k(t.popoverState, {\n          [0]: 1,\n          [1]: 0\n        })\n      };\n      return o.popoverState === 0 && (o.__demoMode = !1), o;\n    },\n    [1](t) {\n      return t.popoverState === 1 ? t : {\n        ...t,\n        popoverState: 1\n      };\n    },\n    [2](t, o) {\n      return t.button === o.button ? t : {\n        ...t,\n        button: o.button\n      };\n    },\n    [3](t, o) {\n      return t.buttonId === o.buttonId ? t : {\n        ...t,\n        buttonId: o.buttonId\n      };\n    },\n    [4](t, o) {\n      return t.panel === o.panel ? t : {\n        ...t,\n        panel: o.panel\n      };\n    },\n    [5](t, o) {\n      return t.panelId === o.panelId ? t : {\n        ...t,\n        panelId: o.panelId\n      };\n    }\n  },\n  ue = Q(null);\nue.displayName = \"PopoverContext\";\nfunction oe(t) {\n  let o = Z(ue);\n  if (o === null) {\n    let u = new Error(`<${t} /> is missing a parent <Popover /> component.`);\n    throw Error.captureStackTrace && Error.captureStackTrace(u, oe), u;\n  }\n  return o;\n}\nlet ie = Q(null);\nie.displayName = \"PopoverAPIContext\";\nfunction fe(t) {\n  let o = Z(ie);\n  if (o === null) {\n    let u = new Error(`<${t} /> is missing a parent <Popover /> component.`);\n    throw Error.captureStackTrace && Error.captureStackTrace(u, fe), u;\n  }\n  return o;\n}\nlet Pe = Q(null);\nPe.displayName = \"PopoverGroupContext\";\nfunction Ee() {\n  return Z(Pe);\n}\nlet re = Q(null);\nre.displayName = \"PopoverPanelContext\";\nfunction Ne() {\n  return Z(re);\n}\nfunction ke(t, o) {\n  return k(o.type, Ge, t, o);\n}\nlet we = \"div\";\nfunction Ue(t, o) {\n  var B;\n  let {\n      __demoMode: u = !1,\n      ...M\n    } = t,\n    x = J(null),\n    n = j(o, Fe(l => {\n      x.current = l;\n    })),\n    e = J([]),\n    c = ge(ke, {\n      __demoMode: u,\n      popoverState: u ? 0 : 1,\n      buttons: e,\n      button: null,\n      buttonId: null,\n      panel: null,\n      panelId: null,\n      beforePanelSentinel: de(),\n      afterPanelSentinel: de()\n    }),\n    [{\n      popoverState: f,\n      button: s,\n      buttonId: I,\n      panel: a,\n      panelId: v,\n      beforePanelSentinel: y,\n      afterPanelSentinel: A\n    }, P] = c,\n    p = ne((B = x.current) != null ? B : s),\n    E = h(() => {\n      if (!s || !a) return !1;\n      for (let W of document.querySelectorAll(\"body > *\")) if (Number(W == null ? void 0 : W.contains(s)) ^ Number(W == null ? void 0 : W.contains(a))) return !0;\n      let l = se(),\n        S = l.indexOf(s),\n        q = (S + l.length - 1) % l.length,\n        U = (S + 1) % l.length,\n        z = l[q],\n        be = l[U];\n      return !a.contains(z) && !a.contains(be);\n    }, [s, a]),\n    F = ve(I),\n    D = ve(v),\n    _ = h(() => ({\n      buttonId: F,\n      panelId: D,\n      close: () => P({\n        type: 1\n      })\n    }), [F, D, P]),\n    O = Ee(),\n    L = O == null ? void 0 : O.registerPopover,\n    $ = R(() => {\n      var l;\n      return (l = O == null ? void 0 : O.isFocusWithinPopoverGroup()) != null ? l : (p == null ? void 0 : p.activeElement) && ((s == null ? void 0 : s.contains(p.activeElement)) || (a == null ? void 0 : a.contains(p.activeElement)));\n    });\n  ee(() => L == null ? void 0 : L(_), [L, _]);\n  let [i, b] = Se(),\n    T = xe({\n      mainTreeNodeRef: O == null ? void 0 : O.mainTreeNodeRef,\n      portals: i,\n      defaultContainers: [s, a]\n    });\n  Re(p == null ? void 0 : p.defaultView, \"focus\", l => {\n    var S, q, U, z;\n    l.target !== window && l.target instanceof HTMLElement && f === 0 && ($() || s && a && (T.contains(l.target) || (q = (S = y.current) == null ? void 0 : S.contains) != null && q.call(S, l.target) || (z = (U = A.current) == null ? void 0 : U.contains) != null && z.call(U, l.target) || P({\n      type: 1\n    })));\n  }, !0), Oe(T.resolveContainers, (l, S) => {\n    P({\n      type: 1\n    }), Le(S, _e.Loose) || (l.preventDefault(), s == null || s.focus());\n  }, f === 0);\n  let d = R(l => {\n      P({\n        type: 1\n      });\n      let S = (() => l ? l instanceof HTMLElement ? l : \"current\" in l && l.current instanceof HTMLElement ? l.current : s : s)();\n      S == null || S.focus();\n    }),\n    r = h(() => ({\n      close: d,\n      isPortalled: E\n    }), [d, E]),\n    m = h(() => ({\n      open: f === 0,\n      close: d\n    }), [f, d]),\n    g = {\n      ref: n\n    };\n  return C.createElement(re.Provider, {\n    value: null\n  }, C.createElement(ue.Provider, {\n    value: c\n  }, C.createElement(ie.Provider, {\n    value: r\n  }, C.createElement(Ie, {\n    value: k(f, {\n      [0]: V.Open,\n      [1]: V.Closed\n    })\n  }, C.createElement(b, null, Y({\n    ourProps: g,\n    theirProps: M,\n    slot: m,\n    defaultTag: we,\n    name: \"Popover\"\n  }), C.createElement(T.MainTreeNode, null))))));\n}\nlet We = \"button\";\nfunction Ke(t, o) {\n  let u = K(),\n    {\n      id: M = `headlessui-popover-button-${u}`,\n      ...x\n    } = t,\n    [n, e] = oe(\"Popover.Button\"),\n    {\n      isPortalled: c\n    } = fe(\"Popover.Button\"),\n    f = J(null),\n    s = `headlessui-focus-sentinel-${K()}`,\n    I = Ee(),\n    a = I == null ? void 0 : I.closeOthers,\n    y = Ne() !== null;\n  ee(() => {\n    if (!y) return e({\n      type: 3,\n      buttonId: M\n    }), () => {\n      e({\n        type: 3,\n        buttonId: null\n      });\n    };\n  }, [y, M, e]);\n  let [A] = ce(() => Symbol()),\n    P = j(f, o, y ? null : r => {\n      if (r) n.buttons.current.push(A);else {\n        let m = n.buttons.current.indexOf(A);\n        m !== -1 && n.buttons.current.splice(m, 1);\n      }\n      n.buttons.current.length > 1 && console.warn(\"You are already using a <Popover.Button /> but only 1 <Popover.Button /> is supported.\"), r && e({\n        type: 2,\n        button: r\n      });\n    }),\n    p = j(f, o),\n    E = ne(f),\n    F = R(r => {\n      var m, g, B;\n      if (y) {\n        if (n.popoverState === 1) return;\n        switch (r.key) {\n          case w.Space:\n          case w.Enter:\n            r.preventDefault(), (g = (m = r.target).click) == null || g.call(m), e({\n              type: 1\n            }), (B = n.button) == null || B.focus();\n            break;\n        }\n      } else switch (r.key) {\n        case w.Space:\n        case w.Enter:\n          r.preventDefault(), r.stopPropagation(), n.popoverState === 1 && (a == null || a(n.buttonId)), e({\n            type: 0\n          });\n          break;\n        case w.Escape:\n          if (n.popoverState !== 0) return a == null ? void 0 : a(n.buttonId);\n          if (!f.current || E != null && E.activeElement && !f.current.contains(E.activeElement)) return;\n          r.preventDefault(), r.stopPropagation(), e({\n            type: 1\n          });\n          break;\n      }\n    }),\n    D = R(r => {\n      y || r.key === w.Space && r.preventDefault();\n    }),\n    _ = R(r => {\n      var m, g;\n      ye(r.currentTarget) || t.disabled || (y ? (e({\n        type: 1\n      }), (m = n.button) == null || m.focus()) : (r.preventDefault(), r.stopPropagation(), n.popoverState === 1 && (a == null || a(n.buttonId)), e({\n        type: 0\n      }), (g = n.button) == null || g.focus()));\n    }),\n    O = R(r => {\n      r.preventDefault(), r.stopPropagation();\n    }),\n    L = n.popoverState === 0,\n    $ = h(() => ({\n      open: L\n    }), [L]),\n    i = Ce(t, f),\n    b = y ? {\n      ref: p,\n      type: i,\n      onKeyDown: F,\n      onClick: _\n    } : {\n      ref: P,\n      id: n.buttonId,\n      type: i,\n      \"aria-expanded\": n.popoverState === 0,\n      \"aria-controls\": n.panel ? n.panelId : void 0,\n      onKeyDown: F,\n      onKeyUp: D,\n      onClick: _,\n      onMouseDown: O\n    },\n    T = Te(),\n    d = R(() => {\n      let r = n.panel;\n      if (!r) return;\n      function m() {\n        k(T.current, {\n          [H.Forwards]: () => N(r, G.First),\n          [H.Backwards]: () => N(r, G.Last)\n        }) === pe.Error && N(se().filter(B => B.dataset.headlessuiFocusGuard !== \"true\"), k(T.current, {\n          [H.Forwards]: G.Next,\n          [H.Backwards]: G.Previous\n        }), {\n          relativeTo: n.button\n        });\n      }\n      m();\n    });\n  return C.createElement(C.Fragment, null, Y({\n    ourProps: b,\n    theirProps: x,\n    slot: $,\n    defaultTag: We,\n    name: \"Popover.Button\"\n  }), L && !y && c && C.createElement(ae, {\n    id: s,\n    features: le.Focusable,\n    \"data-headlessui-focus-guard\": !0,\n    as: \"button\",\n    type: \"button\",\n    onFocus: d\n  }));\n}\nlet je = \"div\",\n  Ve = te.RenderStrategy | te.Static;\nfunction $e(t, o) {\n  let u = K(),\n    {\n      id: M = `headlessui-popover-overlay-${u}`,\n      ...x\n    } = t,\n    [{\n      popoverState: n\n    }, e] = oe(\"Popover.Overlay\"),\n    c = j(o),\n    f = me(),\n    s = (() => f !== null ? (f & V.Open) === V.Open : n === 0)(),\n    I = R(y => {\n      if (ye(y.currentTarget)) return y.preventDefault();\n      e({\n        type: 1\n      });\n    }),\n    a = h(() => ({\n      open: n === 0\n    }), [n]);\n  return Y({\n    ourProps: {\n      ref: c,\n      id: M,\n      \"aria-hidden\": !0,\n      onClick: I\n    },\n    theirProps: x,\n    slot: a,\n    defaultTag: je,\n    features: Ve,\n    visible: s,\n    name: \"Popover.Overlay\"\n  });\n}\nlet Je = \"div\",\n  Xe = te.RenderStrategy | te.Static;\nfunction Ye(t, o) {\n  let u = K(),\n    {\n      id: M = `headlessui-popover-panel-${u}`,\n      focus: x = !1,\n      ...n\n    } = t,\n    [e, c] = oe(\"Popover.Panel\"),\n    {\n      close: f,\n      isPortalled: s\n    } = fe(\"Popover.Panel\"),\n    I = `headlessui-focus-sentinel-before-${K()}`,\n    a = `headlessui-focus-sentinel-after-${K()}`,\n    v = J(null),\n    y = j(v, o, i => {\n      c({\n        type: 4,\n        panel: i\n      });\n    }),\n    A = ne(v),\n    P = De();\n  Ae(() => (c({\n    type: 5,\n    panelId: M\n  }), () => {\n    c({\n      type: 5,\n      panelId: null\n    });\n  }), [M, c]);\n  let p = me(),\n    E = (() => p !== null ? (p & V.Open) === V.Open : e.popoverState === 0)(),\n    F = R(i => {\n      var b;\n      switch (i.key) {\n        case w.Escape:\n          if (e.popoverState !== 0 || !v.current || A != null && A.activeElement && !v.current.contains(A.activeElement)) return;\n          i.preventDefault(), i.stopPropagation(), c({\n            type: 1\n          }), (b = e.button) == null || b.focus();\n          break;\n      }\n    });\n  ee(() => {\n    var i;\n    t.static || e.popoverState === 1 && ((i = t.unmount) == null || i) && c({\n      type: 4,\n      panel: null\n    });\n  }, [e.popoverState, t.unmount, t.static, c]), ee(() => {\n    if (e.__demoMode || !x || e.popoverState !== 0 || !v.current) return;\n    let i = A == null ? void 0 : A.activeElement;\n    v.current.contains(i) || N(v.current, G.First);\n  }, [e.__demoMode, x, v, e.popoverState]);\n  let D = h(() => ({\n      open: e.popoverState === 0,\n      close: f\n    }), [e, f]),\n    _ = {\n      ref: y,\n      id: M,\n      onKeyDown: F,\n      onBlur: x && e.popoverState === 0 ? i => {\n        var T, d, r, m, g;\n        let b = i.relatedTarget;\n        b && v.current && ((T = v.current) != null && T.contains(b) || (c({\n          type: 1\n        }), ((r = (d = e.beforePanelSentinel.current) == null ? void 0 : d.contains) != null && r.call(d, b) || (g = (m = e.afterPanelSentinel.current) == null ? void 0 : m.contains) != null && g.call(m, b)) && b.focus({\n          preventScroll: !0\n        })));\n      } : void 0,\n      tabIndex: -1\n    },\n    O = Te(),\n    L = R(() => {\n      let i = v.current;\n      if (!i) return;\n      function b() {\n        k(O.current, {\n          [H.Forwards]: () => {\n            var d;\n            N(i, G.First) === pe.Error && ((d = e.afterPanelSentinel.current) == null || d.focus());\n          },\n          [H.Backwards]: () => {\n            var T;\n            (T = e.button) == null || T.focus({\n              preventScroll: !0\n            });\n          }\n        });\n      }\n      b();\n    }),\n    $ = R(() => {\n      let i = v.current;\n      if (!i) return;\n      function b() {\n        k(O.current, {\n          [H.Forwards]: () => {\n            var B;\n            if (!e.button) return;\n            let T = se(),\n              d = T.indexOf(e.button),\n              r = T.slice(0, d + 1),\n              g = [...T.slice(d + 1), ...r];\n            for (let l of g.slice()) if (l.dataset.headlessuiFocusGuard === \"true\" || (B = e.panel) != null && B.contains(l)) {\n              let S = g.indexOf(l);\n              S !== -1 && g.splice(S, 1);\n            }\n            N(g, G.First, {\n              sorted: !1\n            });\n          },\n          [H.Backwards]: () => {\n            var d;\n            N(i, G.Previous) === pe.Error && ((d = e.button) == null || d.focus());\n          }\n        });\n      }\n      b();\n    });\n  return C.createElement(re.Provider, {\n    value: M\n  }, E && s && C.createElement(ae, {\n    id: I,\n    ref: e.beforePanelSentinel,\n    features: le.Focusable,\n    \"data-headlessui-focus-guard\": !0,\n    as: \"button\",\n    type: \"button\",\n    onFocus: L\n  }), Y({\n    mergeRefs: P,\n    ourProps: _,\n    theirProps: n,\n    slot: D,\n    defaultTag: Je,\n    features: Xe,\n    visible: E,\n    name: \"Popover.Panel\"\n  }), E && s && C.createElement(ae, {\n    id: a,\n    ref: e.afterPanelSentinel,\n    features: le.Focusable,\n    \"data-headlessui-focus-guard\": !0,\n    as: \"button\",\n    type: \"button\",\n    onFocus: $\n  }));\n}\nlet qe = \"div\";\nfunction ze(t, o) {\n  let u = J(null),\n    M = j(u, o),\n    [x, n] = ce([]),\n    e = Me(),\n    c = R(P => {\n      n(p => {\n        let E = p.indexOf(P);\n        if (E !== -1) {\n          let F = p.slice();\n          return F.splice(E, 1), F;\n        }\n        return p;\n      });\n    }),\n    f = R(P => (n(p => [...p, P]), () => c(P))),\n    s = R(() => {\n      var E;\n      let P = Be(u);\n      if (!P) return !1;\n      let p = P.activeElement;\n      return (E = u.current) != null && E.contains(p) ? !0 : x.some(F => {\n        var D, _;\n        return ((D = P.getElementById(F.buttonId.current)) == null ? void 0 : D.contains(p)) || ((_ = P.getElementById(F.panelId.current)) == null ? void 0 : _.contains(p));\n      });\n    }),\n    I = R(P => {\n      for (let p of x) p.buttonId.current !== P && p.close();\n    }),\n    a = h(() => ({\n      registerPopover: f,\n      unregisterPopover: c,\n      isFocusWithinPopoverGroup: s,\n      closeOthers: I,\n      mainTreeNodeRef: e.mainTreeNodeRef\n    }), [f, c, s, I, e.mainTreeNodeRef]),\n    v = h(() => ({}), []),\n    y = t,\n    A = {\n      ref: M\n    };\n  return C.createElement(Pe.Provider, {\n    value: a\n  }, Y({\n    ourProps: A,\n    theirProps: y,\n    slot: v,\n    defaultTag: qe,\n    name: \"Popover.Group\"\n  }), C.createElement(e.MainTreeNode, null));\n}\nlet Qe = X(Ue),\n  Ze = X(Ke),\n  et = X($e),\n  tt = X(Ye),\n  ot = X(ze),\n  Ct = Object.assign(Qe, {\n    Button: Ze,\n    Overlay: et,\n    Panel: tt,\n    Group: ot\n  });\nexport { Ct as Popover };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}