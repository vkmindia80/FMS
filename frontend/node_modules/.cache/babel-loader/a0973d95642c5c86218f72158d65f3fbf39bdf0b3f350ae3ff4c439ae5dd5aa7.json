{"ast":null,"code":"import E, { createContext as I, Fragment as H, useContext as x, useEffect as h, useMemo as S, useReducer as G, useRef as R } from \"react\";\nimport { useEvent as A } from '../../hooks/use-event.js';\nimport { useId as U } from '../../hooks/use-id.js';\nimport { useResolveButtonType as j } from '../../hooks/use-resolve-button-type.js';\nimport { optionalRef as W, useSyncRefs as L } from '../../hooks/use-sync-refs.js';\nimport { OpenClosedProvider as $, State as b, useOpenClosed as J } from '../../internal/open-closed.js';\nimport { isDisabledReactIssue7711 as X } from '../../utils/bugs.js';\nimport { match as O } from '../../utils/match.js';\nimport { getOwnerDocument as q } from '../../utils/owner.js';\nimport { Features as w, forwardRefWithAs as B, render as k, useMergeRefsFn as N } from '../../utils/render.js';\nimport { startTransition as z } from '../../utils/start-transition.js';\nimport { Keys as g } from '../keyboard.js';\nvar Q = (o => (o[o.Open = 0] = \"Open\", o[o.Closed = 1] = \"Closed\", o))(Q || {}),\n  V = (t => (t[t.ToggleDisclosure = 0] = \"ToggleDisclosure\", t[t.CloseDisclosure = 1] = \"CloseDisclosure\", t[t.SetButtonId = 2] = \"SetButtonId\", t[t.SetPanelId = 3] = \"SetPanelId\", t[t.LinkPanel = 4] = \"LinkPanel\", t[t.UnlinkPanel = 5] = \"UnlinkPanel\", t))(V || {});\nlet Y = {\n    [0]: e => ({\n      ...e,\n      disclosureState: O(e.disclosureState, {\n        [0]: 1,\n        [1]: 0\n      })\n    }),\n    [1]: e => e.disclosureState === 1 ? e : {\n      ...e,\n      disclosureState: 1\n    },\n    [4](e) {\n      return e.linkedPanel === !0 ? e : {\n        ...e,\n        linkedPanel: !0\n      };\n    },\n    [5](e) {\n      return e.linkedPanel === !1 ? e : {\n        ...e,\n        linkedPanel: !1\n      };\n    },\n    [2](e, n) {\n      return e.buttonId === n.buttonId ? e : {\n        ...e,\n        buttonId: n.buttonId\n      };\n    },\n    [3](e, n) {\n      return e.panelId === n.panelId ? e : {\n        ...e,\n        panelId: n.panelId\n      };\n    }\n  },\n  M = I(null);\nM.displayName = \"DisclosureContext\";\nfunction _(e) {\n  let n = x(M);\n  if (n === null) {\n    let o = new Error(`<${e} /> is missing a parent <Disclosure /> component.`);\n    throw Error.captureStackTrace && Error.captureStackTrace(o, _), o;\n  }\n  return n;\n}\nlet v = I(null);\nv.displayName = \"DisclosureAPIContext\";\nfunction K(e) {\n  let n = x(v);\n  if (n === null) {\n    let o = new Error(`<${e} /> is missing a parent <Disclosure /> component.`);\n    throw Error.captureStackTrace && Error.captureStackTrace(o, K), o;\n  }\n  return n;\n}\nlet F = I(null);\nF.displayName = \"DisclosurePanelContext\";\nfunction Z() {\n  return x(F);\n}\nfunction ee(e, n) {\n  return O(n.type, Y, e, n);\n}\nlet te = H;\nfunction ne(e, n) {\n  let {\n      defaultOpen: o = !1,\n      ...i\n    } = e,\n    f = R(null),\n    l = L(n, W(u => {\n      f.current = u;\n    }, e.as === void 0 || e.as === H)),\n    t = R(null),\n    d = R(null),\n    s = G(ee, {\n      disclosureState: o ? 0 : 1,\n      linkedPanel: !1,\n      buttonRef: d,\n      panelRef: t,\n      buttonId: null,\n      panelId: null\n    }),\n    [{\n      disclosureState: c,\n      buttonId: a\n    }, D] = s,\n    p = A(u => {\n      D({\n        type: 1\n      });\n      let y = q(f);\n      if (!y || !a) return;\n      let r = (() => u ? u instanceof HTMLElement ? u : u.current instanceof HTMLElement ? u.current : y.getElementById(a) : y.getElementById(a))();\n      r == null || r.focus();\n    }),\n    P = S(() => ({\n      close: p\n    }), [p]),\n    T = S(() => ({\n      open: c === 0,\n      close: p\n    }), [c, p]),\n    C = {\n      ref: l\n    };\n  return E.createElement(M.Provider, {\n    value: s\n  }, E.createElement(v.Provider, {\n    value: P\n  }, E.createElement($, {\n    value: O(c, {\n      [0]: b.Open,\n      [1]: b.Closed\n    })\n  }, k({\n    ourProps: C,\n    theirProps: i,\n    slot: T,\n    defaultTag: te,\n    name: \"Disclosure\"\n  }))));\n}\nlet le = \"button\";\nfunction oe(e, n) {\n  let o = U(),\n    {\n      id: i = `headlessui-disclosure-button-${o}`,\n      ...f\n    } = e,\n    [l, t] = _(\"Disclosure.Button\"),\n    d = Z(),\n    s = d === null ? !1 : d === l.panelId,\n    c = R(null),\n    a = L(c, n, s ? null : l.buttonRef),\n    D = N();\n  h(() => {\n    if (!s) return t({\n      type: 2,\n      buttonId: i\n    }), () => {\n      t({\n        type: 2,\n        buttonId: null\n      });\n    };\n  }, [i, t, s]);\n  let p = A(r => {\n      var m;\n      if (s) {\n        if (l.disclosureState === 1) return;\n        switch (r.key) {\n          case g.Space:\n          case g.Enter:\n            r.preventDefault(), r.stopPropagation(), t({\n              type: 0\n            }), (m = l.buttonRef.current) == null || m.focus();\n            break;\n        }\n      } else switch (r.key) {\n        case g.Space:\n        case g.Enter:\n          r.preventDefault(), r.stopPropagation(), t({\n            type: 0\n          });\n          break;\n      }\n    }),\n    P = A(r => {\n      switch (r.key) {\n        case g.Space:\n          r.preventDefault();\n          break;\n      }\n    }),\n    T = A(r => {\n      var m;\n      X(r.currentTarget) || e.disabled || (s ? (t({\n        type: 0\n      }), (m = l.buttonRef.current) == null || m.focus()) : t({\n        type: 0\n      }));\n    }),\n    C = S(() => ({\n      open: l.disclosureState === 0\n    }), [l]),\n    u = j(e, c),\n    y = s ? {\n      ref: a,\n      type: u,\n      onKeyDown: p,\n      onClick: T\n    } : {\n      ref: a,\n      id: i,\n      type: u,\n      \"aria-expanded\": l.disclosureState === 0,\n      \"aria-controls\": l.linkedPanel ? l.panelId : void 0,\n      onKeyDown: p,\n      onKeyUp: P,\n      onClick: T\n    };\n  return k({\n    mergeRefs: D,\n    ourProps: y,\n    theirProps: f,\n    slot: C,\n    defaultTag: le,\n    name: \"Disclosure.Button\"\n  });\n}\nlet re = \"div\",\n  se = w.RenderStrategy | w.Static;\nfunction ue(e, n) {\n  let o = U(),\n    {\n      id: i = `headlessui-disclosure-panel-${o}`,\n      ...f\n    } = e,\n    [l, t] = _(\"Disclosure.Panel\"),\n    {\n      close: d\n    } = K(\"Disclosure.Panel\"),\n    s = N(),\n    c = L(n, l.panelRef, T => {\n      z(() => t({\n        type: T ? 4 : 5\n      }));\n    });\n  h(() => (t({\n    type: 3,\n    panelId: i\n  }), () => {\n    t({\n      type: 3,\n      panelId: null\n    });\n  }), [i, t]);\n  let a = J(),\n    D = (() => a !== null ? (a & b.Open) === b.Open : l.disclosureState === 0)(),\n    p = S(() => ({\n      open: l.disclosureState === 0,\n      close: d\n    }), [l, d]),\n    P = {\n      ref: c,\n      id: i\n    };\n  return E.createElement(F.Provider, {\n    value: l.panelId\n  }, k({\n    mergeRefs: s,\n    ourProps: P,\n    theirProps: f,\n    slot: p,\n    defaultTag: re,\n    features: se,\n    visible: D,\n    name: \"Disclosure.Panel\"\n  }));\n}\nlet ie = B(ne),\n  ae = B(oe),\n  pe = B(ue),\n  Ae = Object.assign(ie, {\n    Button: ae,\n    Panel: pe\n  });\nexport { Ae as Disclosure };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}