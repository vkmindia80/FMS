{"ast":null,"code":"import C, { createContext as V, Fragment as ne, useContext as Q, useMemo as I, useReducer as re, useRef as J } from \"react\";\nimport { Keys as y } from '../../components/keyboard.js';\nimport { useEvent as _ } from '../../hooks/use-event.js';\nimport { useId as Y } from '../../hooks/use-id.js';\nimport { useIsoMorphicEffect as N } from '../../hooks/use-iso-morphic-effect.js';\nimport { useLatestValue as B } from '../../hooks/use-latest-value.js';\nimport { useResolveButtonType as ae } from '../../hooks/use-resolve-button-type.js';\nimport { useSyncRefs as w } from '../../hooks/use-sync-refs.js';\nimport { FocusSentinel as le } from '../../internal/focus-sentinel.js';\nimport { Hidden as oe } from '../../internal/hidden.js';\nimport { Focus as x, focusIn as D, FocusResult as j, sortByDomNode as v } from '../../utils/focus-management.js';\nimport { match as G } from '../../utils/match.js';\nimport { microTask as se } from '../../utils/micro-task.js';\nimport { getOwnerDocument as ie } from '../../utils/owner.js';\nimport { Features as Z, forwardRefWithAs as H, render as U } from '../../utils/render.js';\nimport { StableCollection as pe, useStableCollectionIndex as ee } from '../../utils/stable-collection.js';\nvar ue = (t => (t[t.Forwards = 0] = \"Forwards\", t[t.Backwards = 1] = \"Backwards\", t))(ue || {}),\n  Te = (l => (l[l.Less = -1] = \"Less\", l[l.Equal = 0] = \"Equal\", l[l.Greater = 1] = \"Greater\", l))(Te || {}),\n  de = (a => (a[a.SetSelectedIndex = 0] = \"SetSelectedIndex\", a[a.RegisterTab = 1] = \"RegisterTab\", a[a.UnregisterTab = 2] = \"UnregisterTab\", a[a.RegisterPanel = 3] = \"RegisterPanel\", a[a.UnregisterPanel = 4] = \"UnregisterPanel\", a))(de || {});\nlet ce = {\n    [0](e, n) {\n      var i;\n      let t = v(e.tabs, c => c.current),\n        l = v(e.panels, c => c.current),\n        o = t.filter(c => {\n          var p;\n          return !((p = c.current) != null && p.hasAttribute(\"disabled\"));\n        }),\n        a = {\n          ...e,\n          tabs: t,\n          panels: l\n        };\n      if (n.index < 0 || n.index > t.length - 1) {\n        let c = G(Math.sign(n.index - e.selectedIndex), {\n          [-1]: () => 1,\n          [0]: () => G(Math.sign(n.index), {\n            [-1]: () => 0,\n            [0]: () => 0,\n            [1]: () => 1\n          }),\n          [1]: () => 0\n        });\n        if (o.length === 0) return a;\n        let p = G(c, {\n          [0]: () => t.indexOf(o[0]),\n          [1]: () => t.indexOf(o[o.length - 1])\n        });\n        return {\n          ...a,\n          selectedIndex: p === -1 ? e.selectedIndex : p\n        };\n      }\n      let T = t.slice(0, n.index),\n        m = [...t.slice(n.index), ...T].find(c => o.includes(c));\n      if (!m) return a;\n      let b = (i = t.indexOf(m)) != null ? i : e.selectedIndex;\n      return b === -1 && (b = e.selectedIndex), {\n        ...a,\n        selectedIndex: b\n      };\n    },\n    [1](e, n) {\n      if (e.tabs.includes(n.tab)) return e;\n      let t = e.tabs[e.selectedIndex],\n        l = v([...e.tabs, n.tab], a => a.current),\n        o = e.selectedIndex;\n      return e.info.current.isControlled || (o = l.indexOf(t), o === -1 && (o = e.selectedIndex)), {\n        ...e,\n        tabs: l,\n        selectedIndex: o\n      };\n    },\n    [2](e, n) {\n      return {\n        ...e,\n        tabs: e.tabs.filter(t => t !== n.tab)\n      };\n    },\n    [3](e, n) {\n      return e.panels.includes(n.panel) ? e : {\n        ...e,\n        panels: v([...e.panels, n.panel], t => t.current)\n      };\n    },\n    [4](e, n) {\n      return {\n        ...e,\n        panels: e.panels.filter(t => t !== n.panel)\n      };\n    }\n  },\n  X = V(null);\nX.displayName = \"TabsDataContext\";\nfunction F(e) {\n  let n = Q(X);\n  if (n === null) {\n    let t = new Error(`<${e} /> is missing a parent <Tab.Group /> component.`);\n    throw Error.captureStackTrace && Error.captureStackTrace(t, F), t;\n  }\n  return n;\n}\nlet $ = V(null);\n$.displayName = \"TabsActionsContext\";\nfunction q(e) {\n  let n = Q($);\n  if (n === null) {\n    let t = new Error(`<${e} /> is missing a parent <Tab.Group /> component.`);\n    throw Error.captureStackTrace && Error.captureStackTrace(t, q), t;\n  }\n  return n;\n}\nfunction fe(e, n) {\n  return G(n.type, ce, e, n);\n}\nlet be = ne;\nfunction me(e, n) {\n  let {\n    defaultIndex: t = 0,\n    vertical: l = !1,\n    manual: o = !1,\n    onChange: a,\n    selectedIndex: T = null,\n    ...R\n  } = e;\n  const m = l ? \"vertical\" : \"horizontal\",\n    b = o ? \"manual\" : \"auto\";\n  let i = T !== null,\n    c = B({\n      isControlled: i\n    }),\n    p = w(n),\n    [u, f] = re(fe, {\n      info: c,\n      selectedIndex: T != null ? T : t,\n      tabs: [],\n      panels: []\n    }),\n    P = I(() => ({\n      selectedIndex: u.selectedIndex\n    }), [u.selectedIndex]),\n    g = B(a || (() => {})),\n    E = B(u.tabs),\n    L = I(() => ({\n      orientation: m,\n      activation: b,\n      ...u\n    }), [m, b, u]),\n    A = _(s => (f({\n      type: 1,\n      tab: s\n    }), () => f({\n      type: 2,\n      tab: s\n    }))),\n    S = _(s => (f({\n      type: 3,\n      panel: s\n    }), () => f({\n      type: 4,\n      panel: s\n    }))),\n    k = _(s => {\n      h.current !== s && g.current(s), i || f({\n        type: 0,\n        index: s\n      });\n    }),\n    h = B(i ? e.selectedIndex : u.selectedIndex),\n    W = I(() => ({\n      registerTab: A,\n      registerPanel: S,\n      change: k\n    }), []);\n  N(() => {\n    f({\n      type: 0,\n      index: T != null ? T : t\n    });\n  }, [T]), N(() => {\n    if (h.current === void 0 || u.tabs.length <= 0) return;\n    let s = v(u.tabs, d => d.current);\n    s.some((d, M) => u.tabs[M] !== d) && k(s.indexOf(u.tabs[h.current]));\n  });\n  let O = {\n    ref: p\n  };\n  return C.createElement(pe, null, C.createElement($.Provider, {\n    value: W\n  }, C.createElement(X.Provider, {\n    value: L\n  }, L.tabs.length <= 0 && C.createElement(le, {\n    onFocus: () => {\n      var s, r;\n      for (let d of E.current) if (((s = d.current) == null ? void 0 : s.tabIndex) === 0) return (r = d.current) == null || r.focus(), !0;\n      return !1;\n    }\n  }), U({\n    ourProps: O,\n    theirProps: R,\n    slot: P,\n    defaultTag: be,\n    name: \"Tabs\"\n  }))));\n}\nlet Pe = \"div\";\nfunction ye(e, n) {\n  let {\n      orientation: t,\n      selectedIndex: l\n    } = F(\"Tab.List\"),\n    o = w(n);\n  return U({\n    ourProps: {\n      ref: o,\n      role: \"tablist\",\n      \"aria-orientation\": t\n    },\n    theirProps: e,\n    slot: {\n      selectedIndex: l\n    },\n    defaultTag: Pe,\n    name: \"Tabs.List\"\n  });\n}\nlet xe = \"button\";\nfunction ge(e, n) {\n  var O, s;\n  let t = Y(),\n    {\n      id: l = `headlessui-tabs-tab-${t}`,\n      ...o\n    } = e,\n    {\n      orientation: a,\n      activation: T,\n      selectedIndex: R,\n      tabs: m,\n      panels: b\n    } = F(\"Tab\"),\n    i = q(\"Tab\"),\n    c = F(\"Tab\"),\n    p = J(null),\n    u = w(p, n);\n  N(() => i.registerTab(p), [i, p]);\n  let f = ee(\"tabs\"),\n    P = m.indexOf(p);\n  P === -1 && (P = f);\n  let g = P === R,\n    E = _(r => {\n      var M;\n      let d = r();\n      if (d === j.Success && T === \"auto\") {\n        let K = (M = ie(p)) == null ? void 0 : M.activeElement,\n          z = c.tabs.findIndex(te => te.current === K);\n        z !== -1 && i.change(z);\n      }\n      return d;\n    }),\n    L = _(r => {\n      let d = m.map(K => K.current).filter(Boolean);\n      if (r.key === y.Space || r.key === y.Enter) {\n        r.preventDefault(), r.stopPropagation(), i.change(P);\n        return;\n      }\n      switch (r.key) {\n        case y.Home:\n        case y.PageUp:\n          return r.preventDefault(), r.stopPropagation(), E(() => D(d, x.First));\n        case y.End:\n        case y.PageDown:\n          return r.preventDefault(), r.stopPropagation(), E(() => D(d, x.Last));\n      }\n      if (E(() => G(a, {\n        vertical() {\n          return r.key === y.ArrowUp ? D(d, x.Previous | x.WrapAround) : r.key === y.ArrowDown ? D(d, x.Next | x.WrapAround) : j.Error;\n        },\n        horizontal() {\n          return r.key === y.ArrowLeft ? D(d, x.Previous | x.WrapAround) : r.key === y.ArrowRight ? D(d, x.Next | x.WrapAround) : j.Error;\n        }\n      })) === j.Success) return r.preventDefault();\n    }),\n    A = J(!1),\n    S = _(() => {\n      var r;\n      A.current || (A.current = !0, (r = p.current) == null || r.focus({\n        preventScroll: !0\n      }), i.change(P), se(() => {\n        A.current = !1;\n      }));\n    }),\n    k = _(r => {\n      r.preventDefault();\n    }),\n    h = I(() => {\n      var r;\n      return {\n        selected: g,\n        disabled: (r = e.disabled) != null ? r : !1\n      };\n    }, [g, e.disabled]),\n    W = {\n      ref: u,\n      onKeyDown: L,\n      onMouseDown: k,\n      onClick: S,\n      id: l,\n      role: \"tab\",\n      type: ae(e, p),\n      \"aria-controls\": (s = (O = b[P]) == null ? void 0 : O.current) == null ? void 0 : s.id,\n      \"aria-selected\": g,\n      tabIndex: g ? 0 : -1\n    };\n  return U({\n    ourProps: W,\n    theirProps: o,\n    slot: h,\n    defaultTag: xe,\n    name: \"Tabs.Tab\"\n  });\n}\nlet Ee = \"div\";\nfunction Ae(e, n) {\n  let {\n      selectedIndex: t\n    } = F(\"Tab.Panels\"),\n    l = w(n),\n    o = I(() => ({\n      selectedIndex: t\n    }), [t]);\n  return U({\n    ourProps: {\n      ref: l\n    },\n    theirProps: e,\n    slot: o,\n    defaultTag: Ee,\n    name: \"Tabs.Panels\"\n  });\n}\nlet Re = \"div\",\n  Le = Z.RenderStrategy | Z.Static;\nfunction _e(e, n) {\n  var E, L, A, S;\n  let t = Y(),\n    {\n      id: l = `headlessui-tabs-panel-${t}`,\n      tabIndex: o = 0,\n      ...a\n    } = e,\n    {\n      selectedIndex: T,\n      tabs: R,\n      panels: m\n    } = F(\"Tab.Panel\"),\n    b = q(\"Tab.Panel\"),\n    i = J(null),\n    c = w(i, n);\n  N(() => b.registerPanel(i), [b, i, l]);\n  let p = ee(\"panels\"),\n    u = m.indexOf(i);\n  u === -1 && (u = p);\n  let f = u === T,\n    P = I(() => ({\n      selected: f\n    }), [f]),\n    g = {\n      ref: c,\n      id: l,\n      role: \"tabpanel\",\n      \"aria-labelledby\": (L = (E = R[u]) == null ? void 0 : E.current) == null ? void 0 : L.id,\n      tabIndex: f ? o : -1\n    };\n  return !f && ((A = a.unmount) == null || A) && !((S = a.static) != null && S) ? C.createElement(oe, {\n    as: \"span\",\n    \"aria-hidden\": \"true\",\n    ...g\n  }) : U({\n    ourProps: g,\n    theirProps: a,\n    slot: P,\n    defaultTag: Re,\n    features: Le,\n    visible: f,\n    name: \"Tabs.Panel\"\n  });\n}\nlet Se = H(ge),\n  Ie = H(me),\n  De = H(ye),\n  Fe = H(Ae),\n  he = H(_e),\n  $e = Object.assign(Se, {\n    Group: Ie,\n    List: De,\n    Panels: Fe,\n    Panel: he\n  });\nexport { $e as Tab };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}