{"ast":null,"code":"import m, { createContext as Z, Fragment as $, useContext as J, useEffect as F, useMemo as ee, useRef as c, useState as X } from \"react\";\nimport { useDisposables as pe } from '../../hooks/use-disposables.js';\nimport { useEvent as E } from '../../hooks/use-event.js';\nimport { useFlags as he } from '../../hooks/use-flags.js';\nimport { useIsMounted as ve } from '../../hooks/use-is-mounted.js';\nimport { useIsoMorphicEffect as ge } from '../../hooks/use-iso-morphic-effect.js';\nimport { useLatestValue as A } from '../../hooks/use-latest-value.js';\nimport { useServerHandoffComplete as te } from '../../hooks/use-server-handoff-complete.js';\nimport { useSyncRefs as ne } from '../../hooks/use-sync-refs.js';\nimport { useTransition as Ce } from '../../hooks/use-transition.js';\nimport { OpenClosedProvider as Ee, State as b, useOpenClosed as re } from '../../internal/open-closed.js';\nimport { classNames as ie } from '../../utils/class-names.js';\nimport { match as _ } from '../../utils/match.js';\nimport { Features as be, forwardRefWithAs as W, render as oe, RenderStrategy as y } from '../../utils/render.js';\nfunction S(t = \"\") {\n  return t.split(/\\s+/).filter(n => n.length > 1);\n}\nlet I = Z(null);\nI.displayName = \"TransitionContext\";\nvar Se = (r => (r.Visible = \"visible\", r.Hidden = \"hidden\", r))(Se || {});\nfunction ye() {\n  let t = J(I);\n  if (t === null) throw new Error(\"A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.\");\n  return t;\n}\nfunction xe() {\n  let t = J(M);\n  if (t === null) throw new Error(\"A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.\");\n  return t;\n}\nlet M = Z(null);\nM.displayName = \"NestingContext\";\nfunction U(t) {\n  return \"children\" in t ? U(t.children) : t.current.filter(({\n    el: n\n  }) => n.current !== null).filter(({\n    state: n\n  }) => n === \"visible\").length > 0;\n}\nfunction se(t, n) {\n  let r = A(t),\n    s = c([]),\n    R = ve(),\n    D = pe(),\n    p = E((i, e = y.Hidden) => {\n      let a = s.current.findIndex(({\n        el: o\n      }) => o === i);\n      a !== -1 && (_(e, {\n        [y.Unmount]() {\n          s.current.splice(a, 1);\n        },\n        [y.Hidden]() {\n          s.current[a].state = \"hidden\";\n        }\n      }), D.microTask(() => {\n        var o;\n        !U(s) && R.current && ((o = r.current) == null || o.call(r));\n      }));\n    }),\n    x = E(i => {\n      let e = s.current.find(({\n        el: a\n      }) => a === i);\n      return e ? e.state !== \"visible\" && (e.state = \"visible\") : s.current.push({\n        el: i,\n        state: \"visible\"\n      }), () => p(i, y.Unmount);\n    }),\n    h = c([]),\n    v = c(Promise.resolve()),\n    u = c({\n      enter: [],\n      leave: [],\n      idle: []\n    }),\n    g = E((i, e, a) => {\n      h.current.splice(0), n && (n.chains.current[e] = n.chains.current[e].filter(([o]) => o !== i)), n == null || n.chains.current[e].push([i, new Promise(o => {\n        h.current.push(o);\n      })]), n == null || n.chains.current[e].push([i, new Promise(o => {\n        Promise.all(u.current[e].map(([f, N]) => N)).then(() => o());\n      })]), e === \"enter\" ? v.current = v.current.then(() => n == null ? void 0 : n.wait.current).then(() => a(e)) : a(e);\n    }),\n    d = E((i, e, a) => {\n      Promise.all(u.current[e].splice(0).map(([o, f]) => f)).then(() => {\n        var o;\n        (o = h.current.shift()) == null || o();\n      }).then(() => a(e));\n    });\n  return ee(() => ({\n    children: s,\n    register: x,\n    unregister: p,\n    onStart: g,\n    onStop: d,\n    wait: v,\n    chains: u\n  }), [x, p, s, g, d, u, v]);\n}\nfunction Ne() {}\nlet Pe = [\"beforeEnter\", \"afterEnter\", \"beforeLeave\", \"afterLeave\"];\nfunction ae(t) {\n  var r;\n  let n = {};\n  for (let s of Pe) n[s] = (r = t[s]) != null ? r : Ne;\n  return n;\n}\nfunction Re(t) {\n  let n = c(ae(t));\n  return F(() => {\n    n.current = ae(t);\n  }, [t]), n;\n}\nlet De = \"div\",\n  le = be.RenderStrategy;\nfunction He(t, n) {\n  var Q, Y;\n  let {\n      beforeEnter: r,\n      afterEnter: s,\n      beforeLeave: R,\n      afterLeave: D,\n      enter: p,\n      enterFrom: x,\n      enterTo: h,\n      entered: v,\n      leave: u,\n      leaveFrom: g,\n      leaveTo: d,\n      ...i\n    } = t,\n    e = c(null),\n    a = ne(e, n),\n    o = (Q = i.unmount) == null || Q ? y.Unmount : y.Hidden,\n    {\n      show: f,\n      appear: N,\n      initial: T\n    } = ye(),\n    [l, j] = X(f ? \"visible\" : \"hidden\"),\n    z = xe(),\n    {\n      register: L,\n      unregister: O\n    } = z;\n  F(() => L(e), [L, e]), F(() => {\n    if (o === y.Hidden && e.current) {\n      if (f && l !== \"visible\") {\n        j(\"visible\");\n        return;\n      }\n      return _(l, {\n        [\"hidden\"]: () => O(e),\n        [\"visible\"]: () => L(e)\n      });\n    }\n  }, [l, e, L, O, f, o]);\n  let k = A({\n      base: S(i.className),\n      enter: S(p),\n      enterFrom: S(x),\n      enterTo: S(h),\n      entered: S(v),\n      leave: S(u),\n      leaveFrom: S(g),\n      leaveTo: S(d)\n    }),\n    V = Re({\n      beforeEnter: r,\n      afterEnter: s,\n      beforeLeave: R,\n      afterLeave: D\n    }),\n    G = te();\n  F(() => {\n    if (G && l === \"visible\" && e.current === null) throw new Error(\"Did you forget to passthrough the `ref` to the actual DOM node?\");\n  }, [e, l, G]);\n  let Te = T && !N,\n    K = N && f && T,\n    de = (() => !G || Te ? \"idle\" : f ? \"enter\" : \"leave\")(),\n    H = he(0),\n    fe = E(C => _(C, {\n      enter: () => {\n        H.addFlag(b.Opening), V.current.beforeEnter();\n      },\n      leave: () => {\n        H.addFlag(b.Closing), V.current.beforeLeave();\n      },\n      idle: () => {}\n    })),\n    me = E(C => _(C, {\n      enter: () => {\n        H.removeFlag(b.Opening), V.current.afterEnter();\n      },\n      leave: () => {\n        H.removeFlag(b.Closing), V.current.afterLeave();\n      },\n      idle: () => {}\n    })),\n    w = se(() => {\n      j(\"hidden\"), O(e);\n    }, z),\n    B = c(!1);\n  Ce({\n    immediate: K,\n    container: e,\n    classes: k,\n    direction: de,\n    onStart: A(C => {\n      B.current = !0, w.onStart(e, C, fe);\n    }),\n    onStop: A(C => {\n      B.current = !1, w.onStop(e, C, me), C === \"leave\" && !U(w) && (j(\"hidden\"), O(e));\n    })\n  });\n  let P = i,\n    ce = {\n      ref: a\n    };\n  return K ? P = {\n    ...P,\n    className: ie(i.className, ...k.current.enter, ...k.current.enterFrom)\n  } : B.current && (P.className = ie(i.className, (Y = e.current) == null ? void 0 : Y.className), P.className === \"\" && delete P.className), m.createElement(M.Provider, {\n    value: w\n  }, m.createElement(Ee, {\n    value: _(l, {\n      [\"visible\"]: b.Open,\n      [\"hidden\"]: b.Closed\n    }) | H.flags\n  }, oe({\n    ourProps: ce,\n    theirProps: P,\n    defaultTag: De,\n    features: le,\n    visible: l === \"visible\",\n    name: \"Transition.Child\"\n  })));\n}\nfunction Fe(t, n) {\n  let {\n      show: r,\n      appear: s = !1,\n      unmount: R = !0,\n      ...D\n    } = t,\n    p = c(null),\n    x = ne(p, n);\n  te();\n  let h = re();\n  if (r === void 0 && h !== null && (r = (h & b.Open) === b.Open), ![!0, !1].includes(r)) throw new Error(\"A <Transition /> is used but it is missing a `show={true | false}` prop.\");\n  let [v, u] = X(r ? \"visible\" : \"hidden\"),\n    g = se(() => {\n      u(\"hidden\");\n    }),\n    [d, i] = X(!0),\n    e = c([r]);\n  ge(() => {\n    d !== !1 && e.current[e.current.length - 1] !== r && (e.current.push(r), i(!1));\n  }, [e, r]);\n  let a = ee(() => ({\n    show: r,\n    appear: s,\n    initial: d\n  }), [r, s, d]);\n  F(() => {\n    if (r) u(\"visible\");else if (!U(g)) u(\"hidden\");else {\n      let T = p.current;\n      if (!T) return;\n      let l = T.getBoundingClientRect();\n      l.x === 0 && l.y === 0 && l.width === 0 && l.height === 0 && u(\"hidden\");\n    }\n  }, [r, g]);\n  let o = {\n      unmount: R\n    },\n    f = E(() => {\n      var T;\n      d && i(!1), (T = t.beforeEnter) == null || T.call(t);\n    }),\n    N = E(() => {\n      var T;\n      d && i(!1), (T = t.beforeLeave) == null || T.call(t);\n    });\n  return m.createElement(M.Provider, {\n    value: g\n  }, m.createElement(I.Provider, {\n    value: a\n  }, oe({\n    ourProps: {\n      ...o,\n      as: $,\n      children: m.createElement(ue, {\n        ref: x,\n        ...o,\n        ...D,\n        beforeEnter: f,\n        beforeLeave: N\n      })\n    },\n    theirProps: {},\n    defaultTag: $,\n    features: le,\n    visible: v === \"visible\",\n    name: \"Transition\"\n  })));\n}\nfunction _e(t, n) {\n  let r = J(I) !== null,\n    s = re() !== null;\n  return m.createElement(m.Fragment, null, !r && s ? m.createElement(q, {\n    ref: n,\n    ...t\n  }) : m.createElement(ue, {\n    ref: n,\n    ...t\n  }));\n}\nlet q = W(Fe),\n  ue = W(He),\n  Le = W(_e),\n  qe = Object.assign(q, {\n    Child: Le,\n    Root: q\n  });\nexport { qe as Transition };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}