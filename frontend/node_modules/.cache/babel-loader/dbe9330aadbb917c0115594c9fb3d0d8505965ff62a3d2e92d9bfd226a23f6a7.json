{"ast":null,"code":"import O, { createContext as J, useContext as V, useEffect as se, useMemo as D, useReducer as ue, useRef as j } from \"react\";\nimport { Description as de, useDescriptions as X } from '../../components/description/description.js';\nimport { Keys as _ } from '../../components/keyboard.js';\nimport { Label as ce, useLabels as q } from '../../components/label/label.js';\nimport { useControllable as fe } from '../../hooks/use-controllable.js';\nimport { useDisposables as Te } from '../../hooks/use-disposables.js';\nimport { useEvent as E } from '../../hooks/use-event.js';\nimport { useFlags as me } from '../../hooks/use-flags.js';\nimport { useId as Q } from '../../hooks/use-id.js';\nimport { useIsoMorphicEffect as ye } from '../../hooks/use-iso-morphic-effect.js';\nimport { useLatestValue as Re } from '../../hooks/use-latest-value.js';\nimport { useSyncRefs as Y } from '../../hooks/use-sync-refs.js';\nimport { useTreeWalker as be } from '../../hooks/use-tree-walker.js';\nimport { Features as ge, Hidden as Oe } from '../../internal/hidden.js';\nimport { isDisabledReactIssue7711 as Z } from '../../utils/bugs.js';\nimport { Focus as S, focusIn as z, FocusResult as ee, sortByDomNode as Ee } from '../../utils/focus-management.js';\nimport { attemptSubmit as ve, objectToFormEntries as Pe } from '../../utils/form.js';\nimport { match as Ae } from '../../utils/match.js';\nimport { getOwnerDocument as De } from '../../utils/owner.js';\nimport { compact as _e, forwardRefWithAs as te, render as re } from '../../utils/render.js';\nvar Ge = (t => (t[t.RegisterOption = 0] = \"RegisterOption\", t[t.UnregisterOption = 1] = \"UnregisterOption\", t))(Ge || {});\nlet Ce = {\n    [0](o, r) {\n      let t = [...o.options, {\n        id: r.id,\n        element: r.element,\n        propsRef: r.propsRef\n      }];\n      return {\n        ...o,\n        options: Ee(t, p => p.element.current)\n      };\n    },\n    [1](o, r) {\n      let t = o.options.slice(),\n        p = o.options.findIndex(T => T.id === r.id);\n      return p === -1 ? o : (t.splice(p, 1), {\n        ...o,\n        options: t\n      });\n    }\n  },\n  B = J(null);\nB.displayName = \"RadioGroupDataContext\";\nfunction oe(o) {\n  let r = V(B);\n  if (r === null) {\n    let t = new Error(`<${o} /> is missing a parent <RadioGroup /> component.`);\n    throw Error.captureStackTrace && Error.captureStackTrace(t, oe), t;\n  }\n  return r;\n}\nlet $ = J(null);\n$.displayName = \"RadioGroupActionsContext\";\nfunction ne(o) {\n  let r = V($);\n  if (r === null) {\n    let t = new Error(`<${o} /> is missing a parent <RadioGroup /> component.`);\n    throw Error.captureStackTrace && Error.captureStackTrace(t, ne), t;\n  }\n  return r;\n}\nfunction ke(o, r) {\n  return Ae(r.type, Ce, o, r);\n}\nlet Le = \"div\";\nfunction he(o, r) {\n  let t = Q(),\n    {\n      id: p = `headlessui-radiogroup-${t}`,\n      value: T,\n      defaultValue: v,\n      form: M,\n      name: m,\n      onChange: H,\n      by: G = (e, i) => e === i,\n      disabled: P = !1,\n      ...N\n    } = o,\n    y = E(typeof G == \"string\" ? (e, i) => {\n      let n = G;\n      return (e == null ? void 0 : e[n]) === (i == null ? void 0 : i[n]);\n    } : G),\n    [A, L] = ue(ke, {\n      options: []\n    }),\n    a = A.options,\n    [h, R] = q(),\n    [C, U] = X(),\n    k = j(null),\n    W = Y(k, r),\n    [l, s] = fe(T, H, v),\n    b = D(() => a.find(e => !e.propsRef.current.disabled), [a]),\n    x = D(() => a.some(e => y(e.propsRef.current.value, l)), [a, l]),\n    d = E(e => {\n      var n;\n      if (P || y(e, l)) return !1;\n      let i = (n = a.find(f => y(f.propsRef.current.value, e))) == null ? void 0 : n.propsRef.current;\n      return i != null && i.disabled ? !1 : (s == null || s(e), !0);\n    });\n  be({\n    container: k.current,\n    accept(e) {\n      return e.getAttribute(\"role\") === \"radio\" ? NodeFilter.FILTER_REJECT : e.hasAttribute(\"role\") ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_ACCEPT;\n    },\n    walk(e) {\n      e.setAttribute(\"role\", \"none\");\n    }\n  });\n  let F = E(e => {\n      let i = k.current;\n      if (!i) return;\n      let n = De(i),\n        f = a.filter(u => u.propsRef.current.disabled === !1).map(u => u.element.current);\n      switch (e.key) {\n        case _.Enter:\n          ve(e.currentTarget);\n          break;\n        case _.ArrowLeft:\n        case _.ArrowUp:\n          if (e.preventDefault(), e.stopPropagation(), z(f, S.Previous | S.WrapAround) === ee.Success) {\n            let g = a.find(K => K.element.current === (n == null ? void 0 : n.activeElement));\n            g && d(g.propsRef.current.value);\n          }\n          break;\n        case _.ArrowRight:\n        case _.ArrowDown:\n          if (e.preventDefault(), e.stopPropagation(), z(f, S.Next | S.WrapAround) === ee.Success) {\n            let g = a.find(K => K.element.current === (n == null ? void 0 : n.activeElement));\n            g && d(g.propsRef.current.value);\n          }\n          break;\n        case _.Space:\n          {\n            e.preventDefault(), e.stopPropagation();\n            let u = a.find(g => g.element.current === (n == null ? void 0 : n.activeElement));\n            u && d(u.propsRef.current.value);\n          }\n          break;\n      }\n    }),\n    c = E(e => (L({\n      type: 0,\n      ...e\n    }), () => L({\n      type: 1,\n      id: e.id\n    }))),\n    w = D(() => ({\n      value: l,\n      firstOption: b,\n      containsCheckedOption: x,\n      disabled: P,\n      compare: y,\n      ...A\n    }), [l, b, x, P, y, A]),\n    ie = D(() => ({\n      registerOption: c,\n      change: d\n    }), [c, d]),\n    ae = {\n      ref: W,\n      id: p,\n      role: \"radiogroup\",\n      \"aria-labelledby\": h,\n      \"aria-describedby\": C,\n      onKeyDown: F\n    },\n    pe = D(() => ({\n      value: l\n    }), [l]),\n    I = j(null),\n    le = Te();\n  return se(() => {\n    I.current && v !== void 0 && le.addEventListener(I.current, \"reset\", () => {\n      d(v);\n    });\n  }, [I, d]), O.createElement(U, {\n    name: \"RadioGroup.Description\"\n  }, O.createElement(R, {\n    name: \"RadioGroup.Label\"\n  }, O.createElement($.Provider, {\n    value: ie\n  }, O.createElement(B.Provider, {\n    value: w\n  }, m != null && l != null && Pe({\n    [m]: l\n  }).map(([e, i], n) => O.createElement(Oe, {\n    features: ge.Hidden,\n    ref: n === 0 ? f => {\n      var u;\n      I.current = (u = f == null ? void 0 : f.closest(\"form\")) != null ? u : null;\n    } : void 0,\n    ..._e({\n      key: e,\n      as: \"input\",\n      type: \"radio\",\n      checked: i != null,\n      hidden: !0,\n      readOnly: !0,\n      form: M,\n      disabled: P,\n      name: e,\n      value: i\n    })\n  })), re({\n    ourProps: ae,\n    theirProps: N,\n    slot: pe,\n    defaultTag: Le,\n    name: \"RadioGroup\"\n  })))));\n}\nvar xe = (t => (t[t.Empty = 1] = \"Empty\", t[t.Active = 2] = \"Active\", t))(xe || {});\nlet Fe = \"div\";\nfunction we(o, r) {\n  var F;\n  let t = Q(),\n    {\n      id: p = `headlessui-radiogroup-option-${t}`,\n      value: T,\n      disabled: v = !1,\n      ...M\n    } = o,\n    m = j(null),\n    H = Y(m, r),\n    [G, P] = q(),\n    [N, y] = X(),\n    {\n      addFlag: A,\n      removeFlag: L,\n      hasFlag: a\n    } = me(1),\n    h = Re({\n      value: T,\n      disabled: v\n    }),\n    R = oe(\"RadioGroup.Option\"),\n    C = ne(\"RadioGroup.Option\");\n  ye(() => C.registerOption({\n    id: p,\n    element: m,\n    propsRef: h\n  }), [p, C, m, h]);\n  let U = E(c => {\n      var w;\n      if (Z(c.currentTarget)) return c.preventDefault();\n      C.change(T) && (A(2), (w = m.current) == null || w.focus());\n    }),\n    k = E(c => {\n      if (Z(c.currentTarget)) return c.preventDefault();\n      A(2);\n    }),\n    W = E(() => L(2)),\n    l = ((F = R.firstOption) == null ? void 0 : F.id) === p,\n    s = R.disabled || v,\n    b = R.compare(R.value, T),\n    x = {\n      ref: H,\n      id: p,\n      role: \"radio\",\n      \"aria-checked\": b ? \"true\" : \"false\",\n      \"aria-labelledby\": G,\n      \"aria-describedby\": N,\n      \"aria-disabled\": s ? !0 : void 0,\n      tabIndex: (() => s ? -1 : b || !R.containsCheckedOption && l ? 0 : -1)(),\n      onClick: s ? void 0 : U,\n      onFocus: s ? void 0 : k,\n      onBlur: s ? void 0 : W\n    },\n    d = D(() => ({\n      checked: b,\n      disabled: s,\n      active: a(2)\n    }), [b, s, a]);\n  return O.createElement(y, {\n    name: \"RadioGroup.Description\"\n  }, O.createElement(P, {\n    name: \"RadioGroup.Label\"\n  }, re({\n    ourProps: x,\n    theirProps: M,\n    slot: d,\n    defaultTag: Fe,\n    name: \"RadioGroup.Option\"\n  })));\n}\nlet Ie = te(he),\n  Se = te(we),\n  it = Object.assign(Ie, {\n    Option: Se,\n    Label: ce,\n    Description: de\n  });\nexport { it as RadioGroup };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}